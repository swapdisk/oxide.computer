# generated by datamodel-codegen:
#   filename:  oxide.json

from __future__ import annotations

from datetime import datetime
from enum import Enum
from ipaddress import IPv4Address, IPv6Address
from typing import Annotated, Any, Literal, Optional, Union
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel


class AddressLotBlock(BaseModel):
    """
    An address lot block is a part of an address lot and contains a range of addresses. The range is inclusive.
    """

    first_address: str
    """
    The first address of the block (inclusive).
    """
    id: UUID
    """
    The id of the address lot block.
    """
    last_address: str
    """
    The last address of the block (inclusive).
    """


class AddressLotBlockCreate(BaseModel):
    """
    Parameters for creating an address lot block. Fist and last addresses are inclusive.
    """

    first_address: str
    """
    The first address in the lot (inclusive).
    """
    last_address: str
    """
    The last address in the lot (inclusive).
    """


class AddressLotBlockResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[AddressLotBlock]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class AddressLotKind(RootModel[Union[Literal["infra"], Literal["pool"]]]):
    root: Union[Literal["infra"], Literal["pool"]]
    """
    The kind associated with an address lot.
    """


class AllowedSourceIps1(BaseModel):
    """
    Allow traffic from any external IP address.
    """

    allow: Literal["any"]


class AuthzScope(
    RootModel[
        Union[
            Literal["fleet"],
            Literal["silo"],
            Literal["project"],
            Literal["viewable_to_all"],
        ]
    ]
):
    root: Union[
        Literal["fleet"],
        Literal["silo"],
        Literal["project"],
        Literal["viewable_to_all"],
    ]
    """
    Authorization scope for a timeseries.

    This describes the level at which a user must be authorized to read data from a timeseries. For example, fleet-scoping means the data is only visible to an operator or fleet reader. Project-scoped, on the other hand, indicates that a user will see data limited to the projects on which they have read permissions.
    """


class Baseboard(BaseModel):
    """
    Properties that uniquely identify an Oxide hardware component
    """

    part: str
    revision: Annotated[int, Field(ge=0)]
    serial: str


class BfdMode(Enum):
    """
    BFD connection mode.
    """

    single_hop = "single_hop"
    multi_hop = "multi_hop"


class BfdState(
    RootModel[
        Union[Literal["admin_down"], Literal["down"], Literal["init"], Literal["up"]]
    ]
):
    root: Union[Literal["admin_down"], Literal["down"], Literal["init"], Literal["up"]]


class BgpMessageHistory(RootModel[Any]):
    root: Any


class Community(RootModel[int]):
    root: Annotated[int, Field(ge=0)]


class BgpPeerState(
    RootModel[
        Union[
            Literal["idle"],
            Literal["connect"],
            Literal["active"],
            Literal["open_sent"],
            Literal["open_confirm"],
            Literal["session_setup"],
            Literal["established"],
        ]
    ]
):
    root: Union[
        Literal["idle"],
        Literal["connect"],
        Literal["active"],
        Literal["open_sent"],
        Literal["open_confirm"],
        Literal["session_setup"],
        Literal["established"],
    ]
    """
    The current state of a BGP peer.
    """


class BinRangedouble1(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: float
    type: Literal["range_to"]


class BinRangedouble2(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: float
    start: float
    type: Literal["range"]


class BinRangedouble3(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: float
    type: Literal["range_from"]


class BinRangedouble(
    RootModel[Union[BinRangedouble1, BinRangedouble2, BinRangedouble3]]
):
    root: Union[BinRangedouble1, BinRangedouble2, BinRangedouble3]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangefloat1(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: float
    type: Literal["range_to"]


class BinRangefloat2(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: float
    start: float
    type: Literal["range"]


class BinRangefloat3(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: float
    type: Literal["range_from"]


class BinRangefloat(RootModel[Union[BinRangefloat1, BinRangefloat2, BinRangefloat3]]):
    root: Union[BinRangefloat1, BinRangefloat2, BinRangefloat3]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeint161(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: int
    type: Literal["range_to"]


class BinRangeint162(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: int
    start: int
    type: Literal["range"]


class BinRangeint163(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: int
    type: Literal["range_from"]


class BinRangeint16(RootModel[Union[BinRangeint161, BinRangeint162, BinRangeint163]]):
    root: Union[BinRangeint161, BinRangeint162, BinRangeint163]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeint321(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: int
    type: Literal["range_to"]


class BinRangeint322(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: int
    start: int
    type: Literal["range"]


class BinRangeint323(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: int
    type: Literal["range_from"]


class BinRangeint32(RootModel[Union[BinRangeint321, BinRangeint322, BinRangeint323]]):
    root: Union[BinRangeint321, BinRangeint322, BinRangeint323]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeint641(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: int
    type: Literal["range_to"]


class BinRangeint642(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: int
    start: int
    type: Literal["range"]


class BinRangeint643(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: int
    type: Literal["range_from"]


class BinRangeint64(RootModel[Union[BinRangeint641, BinRangeint642, BinRangeint643]]):
    root: Union[BinRangeint641, BinRangeint642, BinRangeint643]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeint81(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: int
    type: Literal["range_to"]


class BinRangeint82(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: int
    start: int
    type: Literal["range"]


class BinRangeint83(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: int
    type: Literal["range_from"]


class BinRangeint8(RootModel[Union[BinRangeint81, BinRangeint82, BinRangeint83]]):
    root: Union[BinRangeint81, BinRangeint82, BinRangeint83]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeuint161(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: Annotated[int, Field(ge=0)]
    type: Literal["range_to"]


class BinRangeuint162(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: Annotated[int, Field(ge=0)]
    start: Annotated[int, Field(ge=0)]
    type: Literal["range"]


class BinRangeuint163(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: Annotated[int, Field(ge=0)]
    type: Literal["range_from"]


class BinRangeuint16(
    RootModel[Union[BinRangeuint161, BinRangeuint162, BinRangeuint163]]
):
    root: Union[BinRangeuint161, BinRangeuint162, BinRangeuint163]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeuint321(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: Annotated[int, Field(ge=0)]
    type: Literal["range_to"]


class BinRangeuint322(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: Annotated[int, Field(ge=0)]
    start: Annotated[int, Field(ge=0)]
    type: Literal["range"]


class BinRangeuint323(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: Annotated[int, Field(ge=0)]
    type: Literal["range_from"]


class BinRangeuint32(
    RootModel[Union[BinRangeuint321, BinRangeuint322, BinRangeuint323]]
):
    root: Union[BinRangeuint321, BinRangeuint322, BinRangeuint323]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeuint641(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: Annotated[int, Field(ge=0)]
    type: Literal["range_to"]


class BinRangeuint642(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: Annotated[int, Field(ge=0)]
    start: Annotated[int, Field(ge=0)]
    type: Literal["range"]


class BinRangeuint643(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: Annotated[int, Field(ge=0)]
    type: Literal["range_from"]


class BinRangeuint64(
    RootModel[Union[BinRangeuint641, BinRangeuint642, BinRangeuint643]]
):
    root: Union[BinRangeuint641, BinRangeuint642, BinRangeuint643]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class BinRangeuint81(BaseModel):
    """
    A range unbounded below and exclusively above, `..end`.
    """

    end: Annotated[int, Field(ge=0)]
    type: Literal["range_to"]


class BinRangeuint82(BaseModel):
    """
    A range bounded inclusively below and exclusively above, `start..end`.
    """

    end: Annotated[int, Field(ge=0)]
    start: Annotated[int, Field(ge=0)]
    type: Literal["range"]


class BinRangeuint83(BaseModel):
    """
    A range bounded inclusively below and unbounded above, `start..`.
    """

    start: Annotated[int, Field(ge=0)]
    type: Literal["range_from"]


class BinRangeuint8(RootModel[Union[BinRangeuint81, BinRangeuint82, BinRangeuint83]]):
    root: Union[BinRangeuint81, BinRangeuint82, BinRangeuint83]
    """
    A type storing a range over `T`.

    This type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively.
    """


class Bindouble(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangedouble
    """
    The range of the support covered by this bin.
    """


class Binfloat(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangefloat
    """
    The range of the support covered by this bin.
    """


class Binint16(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeint16
    """
    The range of the support covered by this bin.
    """


class Binint32(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeint32
    """
    The range of the support covered by this bin.
    """


class Binint64(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeint64
    """
    The range of the support covered by this bin.
    """


class Binint8(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeint8
    """
    The range of the support covered by this bin.
    """


class Binuint16(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeuint16
    """
    The range of the support covered by this bin.
    """


class Binuint32(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeuint32
    """
    The range of the support covered by this bin.
    """


class Binuint64(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeuint64
    """
    The range of the support covered by this bin.
    """


class Binuint8(BaseModel):
    """
    Type storing bin edges and a count of samples within it.
    """

    count: Annotated[int, Field(ge=0)]
    """
    The total count of samples in this bin.
    """
    range: BinRangeuint8
    """
    The range of the support covered by this bin.
    """


class BlockSize(Enum):
    integer_512 = 512
    integer_2048 = 2048
    integer_4096 = 4096


class ByteCount(RootModel[int]):
    root: Annotated[int, Field(ge=0)]
    """
    Byte count to express memory or storage capacity.
    """


class Cumulativedouble(BaseModel):
    """
    A cumulative or counter data type.
    """

    start_time: datetime
    value: float


class Cumulativefloat(BaseModel):
    """
    A cumulative or counter data type.
    """

    start_time: datetime
    value: float


class Cumulativeint64(BaseModel):
    """
    A cumulative or counter data type.
    """

    start_time: datetime
    value: int


class Cumulativeuint64(BaseModel):
    """
    A cumulative or counter data type.
    """

    start_time: datetime
    value: Annotated[int, Field(ge=0)]


class Datum1(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: bool
    type: Literal["bool"]


class Datum2(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: int
    type: Literal["i8"]


class Datum3(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Annotated[int, Field(ge=0)]
    type: Literal["u8"]


class Datum4(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: int
    type: Literal["i16"]


class Datum5(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Annotated[int, Field(ge=0)]
    type: Literal["u16"]


class Datum6(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: int
    type: Literal["i32"]


class Datum7(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Annotated[int, Field(ge=0)]
    type: Literal["u32"]


class Datum8(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: int
    type: Literal["i64"]


class Datum9(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Annotated[int, Field(ge=0)]
    type: Literal["u64"]


class Datum10(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: float
    type: Literal["f32"]


class Datum11(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: float
    type: Literal["f64"]


class Datum12(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: str
    type: Literal["string"]


class DatumItem(RootModel[int]):
    root: Annotated[int, Field(ge=0)]


class Datum13(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: list[DatumItem]
    type: Literal["bytes"]


class Datum14(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Cumulativeint64
    type: Literal["cumulative_i64"]


class Datum15(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Cumulativeuint64
    type: Literal["cumulative_u64"]


class Datum16(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Cumulativefloat
    type: Literal["cumulative_f32"]


class Datum17(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Cumulativedouble
    type: Literal["cumulative_f64"]


class DatumType(Enum):
    """
    The type of an individual datum of a metric.
    """

    bool = "bool"
    i8 = "i8"
    u8 = "u8"
    i16 = "i16"
    u16 = "u16"
    i32 = "i32"
    u32 = "u32"
    i64 = "i64"
    u64 = "u64"
    f32 = "f32"
    f64 = "f64"
    string = "string"
    bytes = "bytes"
    cumulative_i64 = "cumulative_i64"
    cumulative_u64 = "cumulative_u64"
    cumulative_f32 = "cumulative_f32"
    cumulative_f64 = "cumulative_f64"
    histogram_i8 = "histogram_i8"
    histogram_u8 = "histogram_u8"
    histogram_i16 = "histogram_i16"
    histogram_u16 = "histogram_u16"
    histogram_i32 = "histogram_i32"
    histogram_u32 = "histogram_u32"
    histogram_i64 = "histogram_i64"
    histogram_u64 = "histogram_u64"
    histogram_f32 = "histogram_f32"
    histogram_f64 = "histogram_f64"


class DerEncodedKeyPair(BaseModel):
    private_key: str
    """
    request signing RSA private key in PKCS#1 format (base64 encoded der file)
    """
    public_cert: str
    """
    request signing public certificate (base64 encoded der file)
    """


class DeviceAccessTokenRequest(BaseModel):
    client_id: UUID
    device_code: str
    grant_type: str


class DeviceAuthRequest(BaseModel):
    client_id: UUID


class DeviceAuthVerify(BaseModel):
    user_code: str


class Digest1(BaseModel):
    type: Literal["sha256"]
    value: str


class Digest(RootModel[Digest1]):
    root: Digest1


class DiskSource1(BaseModel):
    """
    Create a blank disk
    """

    block_size: BlockSize
    """
    size of blocks for this Disk. valid values are: 512, 2048, or 4096
    """
    type: Literal["blank"]


class DiskSource2(BaseModel):
    """
    Create a disk from a disk snapshot
    """

    snapshot_id: UUID
    type: Literal["snapshot"]


class DiskSource3(BaseModel):
    """
    Create a disk from an image
    """

    image_id: UUID
    type: Literal["image"]


class DiskSource4(BaseModel):
    """
    Create a blank disk that will accept bulk writes or pull blocks from an external source.
    """

    block_size: BlockSize
    type: Literal["importing_blocks"]


class DiskSource(RootModel[Union[DiskSource1, DiskSource2, DiskSource3, DiskSource4]]):
    root: Union[DiskSource1, DiskSource2, DiskSource3, DiskSource4]
    """
    Different sources for a disk
    """


class DiskState1(BaseModel):
    """
    Disk is being initialized
    """

    state: Literal["creating"]


class DiskState2(BaseModel):
    """
    Disk is ready but detached from any Instance
    """

    state: Literal["detached"]


class DiskState3(BaseModel):
    """
    Disk is ready to receive blocks from an external source
    """

    state: Literal["import_ready"]


class DiskState4(BaseModel):
    """
    Disk is importing blocks from a URL
    """

    state: Literal["importing_from_url"]


class DiskState5(BaseModel):
    """
    Disk is importing blocks from bulk writes
    """

    state: Literal["importing_from_bulk_writes"]


class DiskState6(BaseModel):
    """
    Disk is being finalized to state Detached
    """

    state: Literal["finalizing"]


class DiskState7(BaseModel):
    """
    Disk is undergoing maintenance
    """

    state: Literal["maintenance"]


class DiskState8(BaseModel):
    """
    Disk is being attached to the given Instance
    """

    instance: UUID
    state: Literal["attaching"]


class DiskState9(BaseModel):
    """
    Disk is attached to the given Instance
    """

    instance: UUID
    state: Literal["attached"]


class DiskState10(BaseModel):
    """
    Disk is being detached from the given Instance
    """

    instance: UUID
    state: Literal["detaching"]


class DiskState11(BaseModel):
    """
    Disk has been destroyed
    """

    state: Literal["destroyed"]


class DiskState12(BaseModel):
    """
    Disk is unavailable
    """

    state: Literal["faulted"]


class DiskState(
    RootModel[
        Union[
            DiskState1,
            DiskState2,
            DiskState3,
            DiskState4,
            DiskState5,
            DiskState6,
            DiskState7,
            DiskState8,
            DiskState9,
            DiskState10,
            DiskState11,
            DiskState12,
        ]
    ]
):
    root: Union[
        DiskState1,
        DiskState2,
        DiskState3,
        DiskState4,
        DiskState5,
        DiskState6,
        DiskState7,
        DiskState8,
        DiskState9,
        DiskState10,
        DiskState11,
        DiskState12,
    ]
    """
    State of a Disk
    """


class Count(RootModel[int]):
    root: Annotated[int, Field(ge=0)]


class Error(BaseModel):
    """
    Error information from a response.
    """

    error_code: Optional[str] = None
    message: str
    request_id: str


class ExternalIp1(BaseModel):
    ip: str
    kind: Literal["ephemeral"]


class FieldSource(Enum):
    """
    The source from which a field is derived, the target or metric.
    """

    target = "target"
    metric = "metric"


class FieldType(Enum):
    """
    The `FieldType` identifies the data type of a target or metric field.
    """

    string = "string"
    i8 = "i8"
    u8 = "u8"
    i16 = "i16"
    u16 = "u16"
    i32 = "i32"
    u32 = "u32"
    i64 = "i64"
    u64 = "u64"
    ip_addr = "ip_addr"
    uuid = "uuid"
    bool = "bool"


class FieldValue1(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["string"]
    value: str


class FieldValue2(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["i8"]
    value: int


class FieldValue3(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["u8"]
    value: Annotated[int, Field(ge=0)]


class FieldValue4(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["i16"]
    value: int


class FieldValue5(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["u16"]
    value: Annotated[int, Field(ge=0)]


class FieldValue6(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["i32"]
    value: int


class FieldValue7(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["u32"]
    value: Annotated[int, Field(ge=0)]


class FieldValue8(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["i64"]
    value: int


class FieldValue9(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["u64"]
    value: Annotated[int, Field(ge=0)]


class FieldValue10(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["ip_addr"]
    value: str


class FieldValue11(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["uuid"]
    value: UUID


class FieldValue12(BaseModel):
    """
    The `FieldValue` contains the value of a target or metric field.
    """

    type: Literal["bool"]
    value: bool


class FieldValue(
    RootModel[
        Union[
            FieldValue1,
            FieldValue2,
            FieldValue3,
            FieldValue4,
            FieldValue5,
            FieldValue6,
            FieldValue7,
            FieldValue8,
            FieldValue9,
            FieldValue10,
            FieldValue11,
            FieldValue12,
        ]
    ]
):
    root: Union[
        FieldValue1,
        FieldValue2,
        FieldValue3,
        FieldValue4,
        FieldValue5,
        FieldValue6,
        FieldValue7,
        FieldValue8,
        FieldValue9,
        FieldValue10,
        FieldValue11,
        FieldValue12,
    ]
    """
    The `FieldValue` contains the value of a target or metric field.
    """


class FleetRole(Enum):
    admin = "admin"
    collaborator = "collaborator"
    viewer = "viewer"


class FloatingIpParentKind(RootModel[Literal["instance"]]):
    root: Literal["instance"]
    """
    The type of resource that a floating IP is attached to
    """


class Group(BaseModel):
    """
    View of a Group
    """

    display_name: str
    """
    Human-readable name that can identify the group
    """
    id: UUID
    silo_id: UUID
    """
    Uuid of the silo to which this group belongs
    """


class GroupResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Group]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Hostname(RootModel[str]):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: Annotated[
        str,
        Field(
            max_length=253,
            min_length=1,
            pattern="^([a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))(\\.[a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))*$",
            title="An RFC-1035-compliant hostname",
        ),
    ]
    """
    A hostname identifies a host on a network, and is usually a dot-delimited sequence of labels, where each label contains only letters, digits, or the hyphen. See RFCs 1035 and 952 for more details.
    """


class IdentityProviderType(RootModel[Literal["saml"]]):
    root: Literal["saml"]


class IdentityType(Enum):
    """
    Describes what kind of identity is described by an id
    """

    silo_user = "silo_user"
    silo_group = "silo_group"


class IdpMetadataSource1(BaseModel):
    type: Literal["url"]
    url: str


class IdpMetadataSource2(BaseModel):
    data: str
    type: Literal["base64_encoded_xml"]


class IdpMetadataSource(RootModel[Union[IdpMetadataSource1, IdpMetadataSource2]]):
    root: Union[IdpMetadataSource1, IdpMetadataSource2]


class ImageSource1(BaseModel):
    """
    The source of the underlying image.
    """

    id: UUID
    type: Literal["snapshot"]


class ImageSource2(BaseModel):
    """
    Boot the Alpine ISO that ships with the Propolis zone. Intended for development purposes only.
    """

    type: Literal["you_can_boot_anything_as_long_as_its_alpine"]


class ImageSource(RootModel[Union[ImageSource1, ImageSource2]]):
    root: Union[ImageSource1, ImageSource2]
    """
    The source of the underlying image.
    """


class ImportBlocksBulkWrite(BaseModel):
    """
    Parameters for importing blocks with a bulk write
    """

    base64_encoded_data: str
    offset: Annotated[int, Field(ge=0)]


class ImportExportPolicy1(BaseModel):
    """
    Do not perform any filtering.
    """

    type: Literal["no_filtering"]


class InstanceAutoRestartPolicy(
    RootModel[Union[Literal["never"], Literal["best_effort"]]]
):
    root: Union[Literal["never"], Literal["best_effort"]]
    """
    A policy determining when an instance should be automatically restarted by the control plane.
    """


class InstanceCpuCount(RootModel[int]):
    root: Annotated[int, Field(ge=0)]
    """
    The number of CPUs in an Instance
    """


class InstanceNetworkInterfaceAttachment2(BaseModel):
    """
    The default networking configuration for an instance is to create a single primary interface with an automatically-assigned IP address. The IP will be pulled from the Project's default VPC / VPC Subnet.
    """

    type: Literal["default"]


class InstanceNetworkInterfaceAttachment3(BaseModel):
    """
    No network interfaces at all will be created for the instance.
    """

    type: Literal["none"]


class Datum29(RootModel[int]):
    root: Annotated[int, Field(ge=0)]


class InstanceSerialConsoleData(BaseModel):
    """
    Contents of an Instance's serial console buffer.
    """

    data: list[Datum29]
    """
    The bytes starting from the requested offset up to either the end of the buffer or the request's `max_bytes`. Provided as a u8 array rather than a string, as it may not be UTF-8.
    """
    last_byte_offset: Annotated[int, Field(ge=0)]
    """
    The absolute offset since boot (suitable for use as `byte_offset` in a subsequent request) of the last byte returned in `data`.
    """


class InstanceState(
    RootModel[
        Union[
            Literal["creating"],
            Literal["starting"],
            Literal["running"],
            Literal["stopping"],
            Literal["stopped"],
            Literal["rebooting"],
            Literal["migrating"],
            Literal["repairing"],
            Literal["failed"],
            Literal["destroyed"],
        ]
    ]
):
    root: Union[
        Literal["creating"],
        Literal["starting"],
        Literal["running"],
        Literal["stopping"],
        Literal["stopped"],
        Literal["rebooting"],
        Literal["migrating"],
        Literal["repairing"],
        Literal["failed"],
        Literal["destroyed"],
    ]
    """
    Running state of an Instance (primarily: booted or stopped)

    This typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle
    """


class IpPoolSiloLink(BaseModel):
    """
    A link between an IP pool and a silo that allows one to allocate IPs from the pool within the silo
    """

    ip_pool_id: UUID
    is_default: bool
    """
    When a pool is the default for a silo, floating IPs and instance ephemeral IPs will come from that pool when no other pool is specified. There can be at most one default for a given silo.
    """
    silo_id: UUID


class IpPoolSiloLinkResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[IpPoolSiloLink]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class IpPoolSiloUpdate(BaseModel):
    is_default: bool
    """
    When a pool is the default for a silo, floating IPs and instance ephemeral IPs will come from that pool when no other pool is specified. There can be at most one default for a given silo, so when a pool is made default, an existing default will remain linked but will no longer be the default.
    """


class Ipv4Net(RootModel[str]):
    root: Annotated[
        str,
        Field(
            examples=["192.168.1.0/24"],
            pattern="^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|1[0-9]|2[0-9]|3[0-2])$",
            title="An IPv4 subnet",
        ),
    ]
    """
    An IPv4 subnet, including prefix and prefix length
    """


class Ipv4Range(BaseModel):
    """
    A non-decreasing IPv4 address range, inclusive of both ends.

    The first address must be less than or equal to the last address.
    """

    first: IPv4Address
    last: IPv4Address


class Ipv4Utilization(BaseModel):
    allocated: Annotated[int, Field(ge=0)]
    """
    The number of IPv4 addresses allocated from this pool
    """
    capacity: Annotated[int, Field(ge=0)]
    """
    The total number of IPv4 addresses in the pool, i.e., the sum of the lengths of the IPv4 ranges. Unlike IPv6 capacity, can be a 32-bit integer because there are only 2^32 IPv4 addresses.
    """


class Ipv6Net(RootModel[str]):
    root: Annotated[
        str,
        Field(
            examples=["fd12:3456::/64"],
            pattern="^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$",
            title="An IPv6 subnet",
        ),
    ]
    """
    An IPv6 subnet, including prefix and subnet mask
    """


class Ipv6Range(BaseModel):
    """
    A non-decreasing IPv6 address range, inclusive of both ends.

    The first address must be less than or equal to the last address.
    """

    first: IPv6Address
    last: IPv6Address


class Ipv6Utilization(BaseModel):
    allocated: str
    """
    The number of IPv6 addresses allocated from this pool. A 128-bit integer string to match the capacity field.
    """
    capacity: str
    """
    The total number of IPv6 addresses in the pool, i.e., the sum of the lengths of the IPv6 ranges. An IPv6 range can contain up to 2^128 addresses, so we represent this value in JSON as a numeric string with a custom "uint128" format.
    """


class L4PortRange(RootModel[str]):
    root: Annotated[
        str,
        Field(
            examples=["22"],
            max_length=11,
            min_length=1,
            pattern="^[0-9]{1,5}(-[0-9]{1,5})?$",
            title="A range of IP ports",
        ),
    ]
    """
    An inclusive-inclusive range of IP ports. The second port may be omitted to represent a single port.
    """


class LinkFec(RootModel[Union[Literal["firecode"], Literal["none"], Literal["rs"]]]):
    root: Union[Literal["firecode"], Literal["none"], Literal["rs"]]
    """
    The forward error correction mode of a link.
    """


class LinkSpeed(
    RootModel[
        Union[
            Literal["speed0_g"],
            Literal["speed1_g"],
            Literal["speed10_g"],
            Literal["speed25_g"],
            Literal["speed40_g"],
            Literal["speed50_g"],
            Literal["speed100_g"],
            Literal["speed200_g"],
            Literal["speed400_g"],
        ]
    ]
):
    root: Union[
        Literal["speed0_g"],
        Literal["speed1_g"],
        Literal["speed10_g"],
        Literal["speed25_g"],
        Literal["speed40_g"],
        Literal["speed50_g"],
        Literal["speed100_g"],
        Literal["speed200_g"],
        Literal["speed400_g"],
    ]
    """
    The speed of a link.
    """


class LldpLinkConfigCreate(BaseModel):
    """
    The LLDP configuration associated with a port.
    """

    chassis_id: Optional[str] = None
    """
    The LLDP chassis identifier TLV.
    """
    enabled: bool
    """
    Whether or not LLDP is enabled.
    """
    link_description: Optional[str] = None
    """
    The LLDP link description TLV.
    """
    link_name: Optional[str] = None
    """
    The LLDP link name TLV.
    """
    management_ip: Optional[str] = None
    """
    The LLDP management IP TLV.
    """
    system_description: Optional[str] = None
    """
    The LLDP system description TLV.
    """
    system_name: Optional[str] = None
    """
    The LLDP system name TLV.
    """


class MacAddr(RootModel[str]):
    root: Annotated[
        str,
        Field(
            examples=["ff:ff:ff:ff:ff:ff"],
            max_length=17,
            min_length=5,
            pattern="^([0-9a-fA-F]{0,2}:){5}[0-9a-fA-F]{0,2}$",
            title="A MAC address",
        ),
    ]
    """
    A Media Access Control address, in EUI-48 format
    """


class MetricType(
    RootModel[Union[Literal["gauge"], Literal["delta"], Literal["cumulative"]]]
):
    root: Union[Literal["gauge"], Literal["delta"], Literal["cumulative"]]
    """
    The type of the metric itself, indicating what its values represent.
    """


class MissingDatum(BaseModel):
    datum_type: DatumType
    start_time: Optional[datetime] = None


class Name(RootModel[str]):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: Annotated[
        str,
        Field(
            max_length=63,
            min_length=1,
            pattern="^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$",
            title="A name unique within the parent collection",
        ),
    ]
    """
    Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID, but they may contain a UUID. They can be at most 63 characters long.
    """


class NameOrId1(BaseModel):
    pass


class NameOrId(RootModel[Union[NameOrId1, Name]]):
    root: Union[NameOrId1, Name]


class NetworkInterfaceKind1(BaseModel):
    """
    A vNIC attached to a guest instance
    """

    id: UUID
    type: Literal["instance"]


class NetworkInterfaceKind2(BaseModel):
    """
    A vNIC associated with an internal service
    """

    id: UUID
    type: Literal["service"]


class NetworkInterfaceKind3(BaseModel):
    """
    A vNIC associated with a probe
    """

    id: UUID
    type: Literal["probe"]


class NetworkInterfaceKind(
    RootModel[
        Union[NetworkInterfaceKind1, NetworkInterfaceKind2, NetworkInterfaceKind3]
    ]
):
    root: Union[NetworkInterfaceKind1, NetworkInterfaceKind2, NetworkInterfaceKind3]
    """
    The type of network interface
    """


class Password(RootModel[str]):
    root: Annotated[
        str, Field(max_length=512, title="A password used to authenticate a user")
    ]
    """
    Passwords may be subject to additional constraints.
    """


class PhysicalDiskKind(Enum):
    """
    Describes the form factor of physical disks.
    """

    m2 = "m2"
    u2 = "u2"


class PhysicalDiskPolicy1(BaseModel):
    """
    The operator has indicated that the disk is in-service.
    """

    kind: Literal["in_service"]


class PhysicalDiskPolicy2(BaseModel):
    """
    The operator has indicated that the disk has been permanently removed from service.

    This is a terminal state: once a particular disk ID is expunged, it will never return to service. (The actual hardware may be reused, but it will be treated as a brand-new disk.)

    An expunged disk is always non-provisionable.
    """

    kind: Literal["expunged"]


class PhysicalDiskPolicy(RootModel[Union[PhysicalDiskPolicy1, PhysicalDiskPolicy2]]):
    root: Union[PhysicalDiskPolicy1, PhysicalDiskPolicy2]
    """
    The operator-defined policy of a physical disk.
    """


class PhysicalDiskState(RootModel[Union[Literal["active"], Literal["decommissioned"]]]):
    root: Union[Literal["active"], Literal["decommissioned"]]
    """
    The current state of the disk, as determined by Nexus.
    """


class PingStatus(RootModel[Literal["ok"]]):
    root: Literal["ok"]


class Probe(BaseModel):
    """
    Identity-related metadata that's included in nearly all public API objects
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    sled: UUID
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class ProbeCreate(BaseModel):
    """
    Create time parameters for probes.
    """

    description: str
    ip_pool: Optional[NameOrId] = None
    name: Name
    sled: UUID


class ProbeExternalIpKind(Enum):
    snat = "snat"
    floating = "floating"
    ephemeral = "ephemeral"


class Project(BaseModel):
    """
    View of a Project
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class ProjectCreate(BaseModel):
    """
    Create-time parameters for a `Project`
    """

    description: str
    name: Name


class ProjectResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Project]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class ProjectRole(Enum):
    admin = "admin"
    collaborator = "collaborator"
    viewer = "viewer"


class ProjectRoleRoleAssignment(BaseModel):
    """
    Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)

    The resource is not part of this structure.  Rather, `RoleAssignment`s are put into a `Policy` and that Policy is applied to a particular resource.
    """

    identity_id: UUID
    identity_type: IdentityType
    role_name: ProjectRole


class ProjectUpdate(BaseModel):
    """
    Updateable properties of a `Project`
    """

    description: Optional[str] = None
    name: Optional[Name] = None


class MarkerPosition(RootModel[int]):
    root: Annotated[int, Field(ge=0)]


class Quantile(BaseModel):
    """
    Structure for estimating the p-quantile of a population.

    This is based on the PÂ² algorithm for estimating quantiles using constant space.

    The algorithm consists of maintaining five markers: the minimum, the p/2-, p-, and (1 + p)/2 quantiles, and the maximum.
    """

    desired_marker_positions: Annotated[list[float], Field(max_length=5, min_length=5)]
    """
    The desired marker positions.
    """
    marker_heights: Annotated[list[float], Field(max_length=5, min_length=5)]
    """
    The heights of the markers.
    """
    marker_positions: Annotated[list[MarkerPosition], Field(max_length=5, min_length=5)]
    """
    The positions of the markers.

    We track sample size in the 5th position, as useful observations won't start until we've filled the heights at the 6th sample anyway This does deviate from the paper, but it's a more useful representation that works according to the paper's algorithm.
    """
    p: float
    """
    The p value for the quantile.
    """


class Rack(BaseModel):
    """
    View of an Rack
    """

    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class RackResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Rack]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class RoleName(RootModel[str]):
    root: Annotated[
        str,
        Field(
            max_length=63,
            pattern="[a-z-]+\\.[a-z-]+",
            title="A name for a built-in role",
        ),
    ]
    """
    Role names consist of two string components separated by dot (".").
    """


class RouteDestination1(BaseModel):
    """
    Route applies to traffic destined for the specified IP address
    """

    type: Literal["ip"]
    value: str


class RouteDestination3(BaseModel):
    """
    Route applies to traffic destined for the specified VPC
    """

    type: Literal["vpc"]
    value: Name


class RouteDestination4(BaseModel):
    """
    Route applies to traffic destined for the specified VPC subnet
    """

    type: Literal["subnet"]
    value: Name


class RouteTarget1(BaseModel):
    """
    Forward traffic to a particular IP address.
    """

    type: Literal["ip"]
    value: str


class RouteTarget2(BaseModel):
    """
    Forward traffic to a VPC
    """

    type: Literal["vpc"]
    value: Name


class RouteTarget3(BaseModel):
    """
    Forward traffic to a VPC Subnet
    """

    type: Literal["subnet"]
    value: Name


class RouteTarget4(BaseModel):
    """
    Forward traffic to a specific instance
    """

    type: Literal["instance"]
    value: Name


class RouteTarget5(BaseModel):
    """
    Forward traffic to an internet gateway
    """

    type: Literal["internet_gateway"]
    value: Name


class RouteTarget6(BaseModel):
    """
    Drop matching traffic
    """

    type: Literal["drop"]


class RouteTarget(
    RootModel[
        Union[
            RouteTarget1,
            RouteTarget2,
            RouteTarget3,
            RouteTarget4,
            RouteTarget5,
            RouteTarget6,
        ]
    ]
):
    root: Union[
        RouteTarget1,
        RouteTarget2,
        RouteTarget3,
        RouteTarget4,
        RouteTarget5,
        RouteTarget6,
    ]
    """
    A `RouteTarget` describes the possible locations that traffic matching a route destination can be sent.
    """


class RouterRouteKind(
    RootModel[
        Union[
            Literal["default"],
            Literal["vpc_subnet"],
            Literal["vpc_peering"],
            Literal["custom"],
        ]
    ]
):
    root: Union[
        Literal["default"],
        Literal["vpc_subnet"],
        Literal["vpc_peering"],
        Literal["custom"],
    ]
    """
    The kind of a `RouterRoute`

    The kind determines certain attributes such as if the route is modifiable and describes how or where the route was created.
    """


class SamlIdentityProvider(BaseModel):
    """
    Identity-related metadata that's included in nearly all public API objects
    """

    acs_url: str
    """
    Service provider endpoint where the response will be sent
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    group_attribute_name: Optional[str] = None
    """
    If set, attributes with this name will be considered to denote a user's group membership, where the values will be the group names.
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    idp_entity_id: str
    """
    IdP's entity id
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    public_cert: Optional[str] = None
    """
    Optional request signing public certificate (base64 encoded der file)
    """
    slo_url: str
    """
    Service provider endpoint where the idp should send log out requests
    """
    sp_client_id: str
    """
    SP's client id
    """
    technical_contact_email: str
    """
    Customer's technical contact for saml configuration
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SamlIdentityProviderCreate(BaseModel):
    """
    Create-time identity-related parameters
    """

    acs_url: str
    """
    service provider endpoint where the response will be sent
    """
    description: str
    group_attribute_name: Optional[str] = None
    """
    If set, SAML attributes with this name will be considered to denote a user's group membership, where the attribute value(s) should be a comma-separated list of group names.
    """
    idp_entity_id: str
    """
    idp's entity id
    """
    idp_metadata_source: IdpMetadataSource
    """
    the source of an identity provider metadata descriptor
    """
    name: Name
    signing_keypair: Optional[DerEncodedKeyPair] = None
    """
    request signing key pair
    """
    slo_url: str
    """
    service provider endpoint where the idp should send log out requests
    """
    sp_client_id: str
    """
    sp's client id
    """
    technical_contact_email: str
    """
    customer's technical contact for saml configuration
    """


class ServiceUsingCertificate(RootModel[Literal["external_api"]]):
    root: Literal["external_api"]
    """
    The service intended to use this certificate.
    """


class SiloIdentityMode(RootModel[Union[Literal["saml_jit"], Literal["local_only"]]]):
    root: Union[Literal["saml_jit"], Literal["local_only"]]
    """
    Describes how identities are managed and users are authenticated in this Silo
    """


class SiloIpPool(BaseModel):
    """
    An IP pool in the context of a silo
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    is_default: bool
    """
    When a pool is the default for a silo, floating IPs and instance ephemeral IPs will come from that pool when no other pool is specified. There can be at most one default for a given silo.
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SiloIpPoolResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SiloIpPool]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SiloQuotas(BaseModel):
    """
    A collection of resource counts used to set the virtual capacity of a silo
    """

    cpus: int
    """
    Number of virtual CPUs
    """
    memory: ByteCount
    """
    Amount of memory in bytes
    """
    silo_id: UUID
    storage: ByteCount
    """
    Amount of disk storage in bytes
    """


class SiloQuotasCreate(BaseModel):
    """
    The amount of provisionable resources for a Silo
    """

    cpus: int
    """
    The amount of virtual CPUs available for running instances in the Silo
    """
    memory: ByteCount
    """
    The amount of RAM (in bytes) available for running instances in the Silo
    """
    storage: ByteCount
    """
    The amount of storage (in bytes) available for disks or snapshots
    """


class SiloQuotasResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SiloQuotas]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SiloQuotasUpdate(BaseModel):
    """
    Updateable properties of a Silo's resource limits. If a value is omitted it will not be updated.
    """

    cpus: Optional[int] = None
    """
    The amount of virtual CPUs available for running instances in the Silo
    """
    memory: Optional[ByteCount] = None
    """
    The amount of RAM (in bytes) available for running instances in the Silo
    """
    storage: Optional[ByteCount] = None
    """
    The amount of storage (in bytes) available for disks or snapshots
    """


class SiloRole(Enum):
    admin = "admin"
    collaborator = "collaborator"
    viewer = "viewer"


class SiloRoleRoleAssignment(BaseModel):
    """
    Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)

    The resource is not part of this structure.  Rather, `RoleAssignment`s are put into a `Policy` and that Policy is applied to a particular resource.
    """

    identity_id: UUID
    identity_type: IdentityType
    role_name: SiloRole


class SledId(BaseModel):
    """
    The unique ID of a sled.
    """

    id: UUID


class SledInstance(BaseModel):
    """
    An operator's view of an instance running on a given sled
    """

    active_sled_id: UUID
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    memory: int
    migration_id: Optional[UUID] = None
    name: Name
    ncpus: int
    project_name: Name
    silo_name: Name
    state: InstanceState
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SledInstanceResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SledInstance]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SledPolicy2(BaseModel):
    """
    The operator has indicated that the sled has been permanently removed from service.

    This is a terminal state: once a particular sled ID is expunged, it will never return to service. (The actual hardware may be reused, but it will be treated as a brand-new sled.)

    An expunged sled is always non-provisionable.
    """

    kind: Literal["expunged"]


class SledProvisionPolicy(
    RootModel[Union[Literal["provisionable"], Literal["non_provisionable"]]]
):
    root: Union[Literal["provisionable"], Literal["non_provisionable"]]
    """
    The operator-defined provision policy of a sled.

    This controls whether new resources are going to be provisioned on this sled.
    """


class SledProvisionPolicyParams(BaseModel):
    """
    Parameters for `sled_set_provision_policy`.
    """

    state: SledProvisionPolicy
    """
    The provision state.
    """


class SledProvisionPolicyResponse(BaseModel):
    """
    Response to `sled_set_provision_policy`.
    """

    new_state: SledProvisionPolicy
    """
    The new provision state.
    """
    old_state: SledProvisionPolicy
    """
    The old provision state.
    """


class SledState(RootModel[Union[Literal["active"], Literal["decommissioned"]]]):
    root: Union[Literal["active"], Literal["decommissioned"]]
    """
    The current state of the sled, as determined by Nexus.
    """


class SnapshotCreate(BaseModel):
    """
    Create-time parameters for a `Snapshot`
    """

    description: str
    disk: NameOrId
    """
    The disk to be snapshotted
    """
    name: Name


class SnapshotState(Enum):
    creating = "creating"
    ready = "ready"
    faulted = "faulted"
    destroyed = "destroyed"


class SshKey(BaseModel):
    """
    View of an SSH Key
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    public_key: str
    """
    SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
    """
    silo_user_id: UUID
    """
    The user to whom this key belongs
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SshKeyCreate(BaseModel):
    """
    Create-time parameters for an `SshKey`
    """

    description: str
    name: Name
    public_key: str
    """
    SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
    """


class SshKeyResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SshKey]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SupportBundleState(
    RootModel[
        Union[
            Literal["collecting"],
            Literal["destroying"],
            Literal["failed"],
            Literal["active"],
        ]
    ]
):
    root: Union[
        Literal["collecting"],
        Literal["destroying"],
        Literal["failed"],
        Literal["active"],
    ]


class Switch(BaseModel):
    """
    An operator's view of a Switch.
    """

    baseboard: Baseboard
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    rack_id: UUID
    """
    The rack to which this Switch is currently attached
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SwitchInterfaceKind1(BaseModel):
    """
    Primary interfaces are associated with physical links. There is exactly one primary interface per physical link.
    """

    type: Literal["primary"]


class SwitchInterfaceKind3(BaseModel):
    """
    VLAN interfaces allow physical interfaces to be multiplexed onto multiple logical links, each distinguished by a 12-bit 802.1Q Ethernet tag.
    """

    type: Literal["vlan"]
    vid: Annotated[int, Field(ge=0)]
    """
    The virtual network id (VID) that distinguishes this interface and is used for producing and consuming 802.1Q Ethernet tags. This field has a maximum value of 4095 as 802.1Q tags are twelve bits.
    """


class SwitchInterfaceKind4(BaseModel):
    """
    Loopback interfaces are anchors for IP addresses that are not specific to any particular port.
    """

    type: Literal["loopback"]


class SwitchInterfaceKind(
    RootModel[Union[SwitchInterfaceKind1, SwitchInterfaceKind3, SwitchInterfaceKind4]]
):
    root: Union[SwitchInterfaceKind1, SwitchInterfaceKind3, SwitchInterfaceKind4]
    """
    Indicates the kind for a switch interface.
    """


class SwitchInterfaceKind2(
    RootModel[Union[Literal["primary"], Literal["vlan"], Literal["loopback"]]]
):
    root: Union[Literal["primary"], Literal["vlan"], Literal["loopback"]]
    """
    Describes the kind of an switch interface.
    """


class SwitchLinkState(RootModel[Any]):
    root: Any


class SwitchLocation(RootModel[Union[Literal["switch0"], Literal["switch1"]]]):
    root: Union[Literal["switch0"], Literal["switch1"]]
    """
    Identifies switch physical location
    """


class SwitchPort(BaseModel):
    """
    A switch port represents a physical external port on a rack switch.
    """

    id: UUID
    """
    The id of the switch port.
    """
    port_name: str
    """
    The name of this switch port.
    """
    port_settings_id: Optional[UUID] = None
    """
    The primary settings group of this switch port. Will be `None` until this switch port is configured.
    """
    rack_id: UUID
    """
    The rack this switch port belongs to.
    """
    switch_location: str
    """
    The switch location of this switch port.
    """


class SwitchPortApplySettings(BaseModel):
    """
    Parameters for applying settings to switch ports.
    """

    port_settings: NameOrId
    """
    A name or id to use when applying switch port settings.
    """


class SwitchPortGeometry(
    RootModel[Union[Literal["qsfp28x1"], Literal["qsfp28x2"], Literal["sfp28x4"]]]
):
    root: Union[Literal["qsfp28x1"], Literal["qsfp28x2"], Literal["sfp28x4"]]
    """
    The link geometry associated with a switch port.
    """


class SwitchPortGeometry2(
    RootModel[Union[Literal["qsfp28x1"], Literal["qsfp28x2"], Literal["sfp28x4"]]]
):
    root: Union[Literal["qsfp28x1"], Literal["qsfp28x2"], Literal["sfp28x4"]]
    """
    The link geometry associated with a switch port.
    """


class SwitchPortLinkConfig(BaseModel):
    """
    A link configuration for a port settings object.
    """

    autoneg: bool
    """
    Whether or not the link has autonegotiation enabled.
    """
    fec: Optional[LinkFec] = None
    """
    The requested forward-error correction method.  If this is not specified, the standard FEC for the underlying media will be applied if it can be determined.
    """
    link_name: str
    """
    The name of this link.
    """
    lldp_link_config_id: Optional[UUID] = None
    """
    The link-layer discovery protocol service configuration id for this link.
    """
    mtu: Annotated[int, Field(ge=0)]
    """
    The maximum transmission unit for this link.
    """
    port_settings_id: UUID
    """
    The port settings this link configuration belongs to.
    """
    speed: LinkSpeed
    """
    The configured speed of the link.
    """
    tx_eq_config_id: Optional[UUID] = None
    """
    The tx_eq configuration id for this link.
    """


class SwitchPortResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SwitchPort]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SwitchPortSettings(BaseModel):
    """
    A switch port settings identity whose id may be used to view additional details.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SwitchPortSettingsGroups(BaseModel):
    """
    This structure maps a port settings object to a port settings groups. Port settings objects may inherit settings from groups. This mapping defines the relationship between settings objects and the groups they reference.
    """

    port_settings_group_id: UUID
    """
    The id of a port settings group being referenced by a port settings object.
    """
    port_settings_id: UUID
    """
    The id of a port settings object referencing a port settings group.
    """


class SwitchPortSettingsResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SwitchPortSettings]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SwitchResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Switch]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SwitchVlanInterfaceConfig(BaseModel):
    """
    A switch port VLAN interface configuration for a port settings object.
    """

    interface_config_id: UUID
    """
    The switch interface configuration this VLAN interface configuration belongs to.
    """
    vlan_id: Annotated[int, Field(ge=0)]
    """
    The virtual network id for this interface that is used for producing and consuming 802.1Q Ethernet tags. This field has a maximum value of 4095 as 802.1Q tags are twelve bits.
    """


class TimeseriesDescription(BaseModel):
    """
    Text descriptions for the target and metric of a timeseries.
    """

    metric: str
    target: str


class TimeseriesName(RootModel[str]):
    root: Annotated[
        str,
        Field(
            pattern="^(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)$",
            title="The name of a timeseries",
        ),
    ]
    """
    Names are constructed by concatenating the target and metric names with ':'. Target and metric names must be lowercase alphanumeric characters with '_' separating words.
    """


class TimeseriesQuery(BaseModel):
    """
    A timeseries query string, written in the Oximeter query language.
    """

    query: str
    """
    A timeseries query string, written in the Oximeter query language.
    """


class TxEqConfig(BaseModel):
    """
    Per-port tx-eq overrides.  This can be used to fine-tune the transceiver equalization settings to improve signal integrity.
    """

    main: Optional[int] = None
    """
    Main tap
    """
    post1: Optional[int] = None
    """
    Post-cursor tap1
    """
    post2: Optional[int] = None
    """
    Post-cursor tap2
    """
    pre1: Optional[int] = None
    """
    Pre-cursor tap1
    """
    pre2: Optional[int] = None
    """
    Pre-cursor tap2
    """


class TypedUuidForSupportBundleKind(RootModel[UUID]):
    root: UUID


class UninitializedSled(BaseModel):
    """
    A sled that has not been added to an initialized rack yet
    """

    baseboard: Baseboard
    cubby: Annotated[int, Field(ge=0)]
    rack_id: UUID


class UninitializedSledId(BaseModel):
    """
    The unique hardware ID for a sled
    """

    part: str
    serial: str


class UninitializedSledResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[UninitializedSled]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Units1(Enum):
    """
    Measurement units for timeseries samples.
    """

    count = "count"
    bytes = "bytes"
    seconds = "seconds"
    nanoseconds = "nanoseconds"
    volts = "volts"
    amps = "amps"
    watts = "watts"
    degrees_celsius = "degrees_celsius"


class Units(RootModel[Union[Units1, Literal["none"], Literal["rpm"]]]):
    root: Union[Units1, Literal["none"], Literal["rpm"]]
    """
    Measurement units for timeseries samples.
    """


class User(BaseModel):
    """
    View of a User
    """

    display_name: str
    """
    Human-readable name that can identify the user
    """
    id: UUID
    silo_id: UUID
    """
    Uuid of the silo to which this user belongs
    """


class UserBuiltin(BaseModel):
    """
    View of a Built-in User

    Built-in users are identities internal to the system, used when the control plane performs actions autonomously
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class UserBuiltinResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[UserBuiltin]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class UserId(RootModel[str]):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: Annotated[
        str,
        Field(
            max_length=63,
            min_length=1,
            pattern="^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$",
            title="A username for a local-only user",
        ),
    ]
    """
    Usernames must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Usernames cannot be a UUID, but they may contain a UUID. They can be at most 63 characters long.
    """


class UserPassword1(BaseModel):
    """
    Sets the user's password to the provided value
    """

    mode: Literal["password"]
    value: Password


class UserPassword2(BaseModel):
    """
    Invalidates any current password (disabling password authentication)
    """

    mode: Literal["login_disallowed"]


class UserPassword(RootModel[Union[UserPassword1, UserPassword2]]):
    root: Union[UserPassword1, UserPassword2]
    """
    Parameters for setting a user's password
    """


class UserResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[User]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class UsernamePasswordCredentials(BaseModel):
    """
    Credentials for local user login
    """

    password: Password
    username: UserId


class ValueArray1(BaseModel):
    """
    List of data values for one timeseries.

    Each element is an option, where `None` represents a missing sample.
    """

    type: Literal["integer"]
    values: list[Optional[int]]


class ValueArray2(BaseModel):
    """
    List of data values for one timeseries.

    Each element is an option, where `None` represents a missing sample.
    """

    type: Literal["double"]
    values: list[Optional[float]]


class ValueArray3(BaseModel):
    """
    List of data values for one timeseries.

    Each element is an option, where `None` represents a missing sample.
    """

    type: Literal["boolean"]
    values: list[Optional[bool]]


class ValueArray4(BaseModel):
    """
    List of data values for one timeseries.

    Each element is an option, where `None` represents a missing sample.
    """

    type: Literal["string"]
    values: list[Optional[str]]


class VirtualResourceCounts(BaseModel):
    """
    A collection of resource counts used to describe capacity and utilization
    """

    cpus: int
    """
    Number of virtual CPUs
    """
    memory: ByteCount
    """
    Amount of memory in bytes
    """
    storage: ByteCount
    """
    Amount of disk storage in bytes
    """


class Vni(RootModel[int]):
    root: Annotated[int, Field(ge=0)]
    """
    A Geneve Virtual Network Identifier
    """


class Vpc(BaseModel):
    """
    View of a VPC
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    dns_name: Name
    """
    The name used for the VPC in DNS.
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    ipv6_prefix: Ipv6Net
    """
    The unique local IPv6 address range for subnets in this VPC
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    project_id: UUID
    """
    id for the project containing this VPC
    """
    system_router_id: UUID
    """
    id for the system router where subnet default routes are registered
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class VpcCreate(BaseModel):
    """
    Create-time parameters for a `Vpc`
    """

    description: str
    dns_name: Name
    ipv6_prefix: Optional[Ipv6Net] = None
    """
    The IPv6 prefix for this VPC

    All IPv6 subnets created from this VPC must be taken from this range, which should be a Unique Local Address in the range `fd00::/48`. The default VPC Subnet will have the first `/64` range from this prefix.
    """
    name: Name


class VpcFirewallRuleAction(Enum):
    allow = "allow"
    deny = "deny"


class VpcFirewallRuleDirection(Enum):
    inbound = "inbound"
    outbound = "outbound"


class VpcFirewallRuleHostFilter1(BaseModel):
    """
    The rule applies to traffic from/to all instances in the VPC
    """

    type: Literal["vpc"]
    value: Name


class VpcFirewallRuleHostFilter2(BaseModel):
    """
    The rule applies to traffic from/to all instances in the VPC Subnet
    """

    type: Literal["subnet"]
    value: Name


class VpcFirewallRuleHostFilter3(BaseModel):
    """
    The rule applies to traffic from/to this specific instance
    """

    type: Literal["instance"]
    value: Name


class VpcFirewallRuleHostFilter4(BaseModel):
    """
    The rule applies to traffic from/to a specific IP address
    """

    type: Literal["ip"]
    value: str


class VpcFirewallRuleProtocol(Enum):
    """
    The protocols that may be specified in a firewall rule's filter
    """

    TCP = "TCP"
    UDP = "UDP"
    ICMP = "ICMP"


class VpcFirewallRuleStatus(Enum):
    disabled = "disabled"
    enabled = "enabled"


class VpcFirewallRuleTarget1(BaseModel):
    """
    The rule applies to all instances in the VPC
    """

    type: Literal["vpc"]
    value: Name


class VpcFirewallRuleTarget2(BaseModel):
    """
    The rule applies to all instances in the VPC Subnet
    """

    type: Literal["subnet"]
    value: Name


class VpcFirewallRuleTarget3(BaseModel):
    """
    The rule applies to this specific instance
    """

    type: Literal["instance"]
    value: Name


class VpcFirewallRuleTarget4(BaseModel):
    """
    The rule applies to a specific IP address
    """

    type: Literal["ip"]
    value: str


class VpcResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Vpc]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class VpcRouterCreate(BaseModel):
    """
    Create-time parameters for a `VpcRouter`
    """

    description: str
    name: Name


class VpcRouterKind(Enum):
    system = "system"
    custom = "custom"


class VpcRouterUpdate(BaseModel):
    """
    Updateable properties of a `VpcRouter`
    """

    description: Optional[str] = None
    name: Optional[Name] = None


class VpcSubnet(BaseModel):
    """
    A VPC subnet represents a logical grouping for instances that allows network traffic between them, within a IPv4 subnetwork or optionally an IPv6 subnetwork.
    """

    custom_router_id: Optional[UUID] = None
    """
    ID for an attached custom router.
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    ipv4_block: Ipv4Net
    """
    The IPv4 subnet CIDR block.
    """
    ipv6_block: Ipv6Net
    """
    The IPv6 subnet CIDR block.
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    vpc_id: UUID
    """
    The VPC to which the subnet belongs.
    """


class VpcSubnetCreate(BaseModel):
    """
    Create-time parameters for a `VpcSubnet`
    """

    custom_router: Optional[NameOrId] = None
    """
    An optional router, used to direct packets sent from hosts in this subnet to any destination address.

    Custom routers apply in addition to the VPC-wide *system* router, and have higher priority than the system router for an otherwise equal-prefix-length match.
    """
    description: str
    ipv4_block: Ipv4Net
    """
    The IPv4 address range for this subnet.

    It must be allocated from an RFC 1918 private address range, and must not overlap with any other existing subnet in the VPC.
    """
    ipv6_block: Optional[Ipv6Net] = None
    """
    The IPv6 address range for this subnet.

    It must be allocated from the RFC 4193 Unique Local Address range, with the prefix equal to the parent VPC's prefix. A random `/64` block will be assigned if one is not provided. It must not overlap with any existing subnet in the VPC.
    """
    name: Name


class VpcSubnetResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[VpcSubnet]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class VpcSubnetUpdate(BaseModel):
    """
    Updateable properties of a `VpcSubnet`
    """

    custom_router: Optional[NameOrId] = None
    """
    An optional router, used to direct packets sent from hosts in this subnet to any destination address.
    """
    description: Optional[str] = None
    name: Optional[Name] = None


class VpcUpdate(BaseModel):
    """
    Updateable properties of a `Vpc`
    """

    description: Optional[str] = None
    dns_name: Optional[Name] = None
    name: Optional[Name] = None


class NameOrIdSortMode(
    RootModel[
        Union[
            Literal["name_ascending"],
            Literal["name_descending"],
            Literal["id_ascending"],
        ]
    ]
):
    root: Union[
        Literal["name_ascending"], Literal["name_descending"], Literal["id_ascending"]
    ]
    """
    Supported set of sort modes for scanning by name or id
    """


class IdSortMode(RootModel[Literal["id_ascending"]]):
    root: Literal["id_ascending"]
    """
    Supported set of sort modes for scanning by id only.

    Currently, we only support scanning in ascending order.
    """


class DiskMetricName(Enum):
    activated = "activated"
    flush = "flush"
    read = "read"
    read_bytes = "read_bytes"
    write = "write"
    write_bytes = "write_bytes"


class PaginationOrder(Enum):
    """
    The order in which the client wants to page through the requested collection
    """

    ascending = "ascending"
    descending = "descending"


class SystemMetricName(Enum):
    virtual_disk_space_provisioned = "virtual_disk_space_provisioned"
    cpus_provisioned = "cpus_provisioned"
    ram_provisioned = "ram_provisioned"


class NameSortMode(RootModel[Literal["name_ascending"]]):
    root: Literal["name_ascending"]
    """
    Supported set of sort modes for scanning by name only

    Currently, we only support scanning in ascending order.
    """


class AddressLot(BaseModel):
    """
    Represents an address lot object, containing the id of the lot that can be used in other API calls.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    kind: AddressLotKind
    """
    Desired use of `AddressLot`
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class AddressLotCreate(BaseModel):
    """
    Parameters for creating an address lot.
    """

    blocks: list[AddressLotBlockCreate]
    """
    The blocks to add along with the new address lot.
    """
    description: str
    kind: AddressLotKind
    """
    The kind of address lot to create.
    """
    name: Name


class AddressLotCreateResponse(BaseModel):
    """
    An address lot and associated blocks resulting from creating an address lot.
    """

    blocks: list[AddressLotBlock]
    """
    The address lot blocks that were created.
    """
    lot: AddressLot
    """
    The address lot that was created.
    """


class AddressLotResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[AddressLot]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class BfdSessionDisable(BaseModel):
    """
    Information needed to disable a BFD session
    """

    remote: str
    """
    Address of the remote peer to disable a BFD session for.
    """
    switch: Name
    """
    The switch to enable this session on. Must be `switch0` or `switch1`.
    """


class BfdSessionEnable(BaseModel):
    """
    Information about a bidirectional forwarding detection (BFD) session.
    """

    detection_threshold: Annotated[int, Field(ge=0)]
    """
    The negotiated Control packet transmission interval, multiplied by this variable, will be the Detection Time for this session (as seen by the remote system)
    """
    local: Optional[str] = None
    """
    Address the Oxide switch will listen on for BFD traffic. If `None` then the unspecified address (0.0.0.0 or ::) is used.
    """
    mode: BfdMode
    """
    Select either single-hop (RFC 5881) or multi-hop (RFC 5883)
    """
    remote: str
    """
    Address of the remote peer to establish a BFD session with.
    """
    required_rx: Annotated[int, Field(ge=0)]
    """
    The minimum interval, in microseconds, between received BFD Control packets that this system requires
    """
    switch: Name
    """
    The switch to enable this session on. Must be `switch0` or `switch1`.
    """


class BfdStatus(BaseModel):
    detection_threshold: Annotated[int, Field(ge=0)]
    local: Optional[str] = None
    mode: BfdMode
    peer: str
    required_rx: Annotated[int, Field(ge=0)]
    state: BfdState
    switch: Name


class BgpAnnounceSet(BaseModel):
    """
    Represents a BGP announce set by id. The id can be used with other API calls to view and manage the announce set.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class BgpConfig(BaseModel):
    """
    A base BGP configuration.
    """

    asn: Annotated[int, Field(ge=0)]
    """
    The autonomous system number of this BGP configuration.
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    vrf: Optional[str] = None
    """
    Optional virtual routing and forwarding identifier for this BGP configuration.
    """


class BgpConfigCreate(BaseModel):
    """
    Parameters for creating a BGP configuration. This includes and autonomous system number (ASN) and a virtual routing and forwarding (VRF) identifier.
    """

    asn: Annotated[int, Field(ge=0)]
    """
    The autonomous system number of this BGP configuration.
    """
    bgp_announce_set_id: NameOrId
    description: str
    name: Name
    vrf: Optional[Name] = None
    """
    Optional virtual routing and forwarding identifier for this BGP configuration.
    """


class BgpConfigResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[BgpConfig]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class BgpExported(BaseModel):
    """
    The current status of a BGP peer.
    """

    exports: dict[str, list[Ipv4Net]]
    """
    Exported routes indexed by peer address.
    """


class BgpImportedRouteIpv4(BaseModel):
    """
    A route imported from a BGP peer.
    """

    id: Annotated[int, Field(ge=0)]
    """
    BGP identifier of the originating router.
    """
    nexthop: IPv4Address
    """
    The nexthop the prefix is reachable through.
    """
    prefix: Ipv4Net
    """
    The destination network prefix.
    """
    switch: SwitchLocation
    """
    Switch the route is imported into.
    """


class BgpPeerStatus(BaseModel):
    """
    The current status of a BGP peer.
    """

    addr: str
    """
    IP address of the peer.
    """
    local_asn: Annotated[int, Field(ge=0)]
    """
    Local autonomous system number.
    """
    remote_asn: Annotated[int, Field(ge=0)]
    """
    Remote autonomous system number.
    """
    state: BgpPeerState
    """
    State of the peer.
    """
    state_duration_millis: Annotated[int, Field(ge=0)]
    """
    Time of last state change.
    """
    switch: SwitchLocation
    """
    Switch with the peer session.
    """


class Certificate(BaseModel):
    """
    View of a Certificate
    """

    cert: str
    """
    PEM-formatted string containing public certificate chain
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    service: ServiceUsingCertificate
    """
    The service using this certificate
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class CertificateCreate(BaseModel):
    """
    Create-time parameters for a `Certificate`
    """

    cert: str
    """
    PEM-formatted string containing public certificate chain
    """
    description: str
    key: str
    """
    PEM-formatted string containing private key
    """
    name: Name
    service: ServiceUsingCertificate
    """
    The service using this certificate
    """


class CertificateResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Certificate]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class CurrentUser(BaseModel):
    """
    Info about the current user
    """

    display_name: str
    """
    Human-readable name that can identify the user
    """
    id: UUID
    silo_id: UUID
    """
    Uuid of the silo to which this user belongs
    """
    silo_name: Name
    """
    Name of the silo to which this user belongs.
    """


class Datum28(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: MissingDatum
    type: Literal["missing"]


class Disk(BaseModel):
    """
    View of a Disk
    """

    block_size: ByteCount
    description: str
    """
    human-readable free-form text about a resource
    """
    device_path: str
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    image_id: Optional[UUID] = None
    """
    ID of image from which disk was created, if any
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    project_id: UUID
    size: ByteCount
    snapshot_id: Optional[UUID] = None
    """
    ID of snapshot from which disk was created, if any
    """
    state: DiskState
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class DiskCreate(BaseModel):
    """
    Create-time parameters for a `Disk`
    """

    description: str
    disk_source: DiskSource
    """
    The initial source for this disk
    """
    name: Name
    size: ByteCount
    """
    The total size of the Disk (in bytes)
    """


class DiskPath(BaseModel):
    disk: NameOrId
    """
    Name or ID of the disk
    """


class DiskResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Disk]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Distributiondouble(BaseModel):
    """
    A distribution is a sequence of bins and counts in those bins, and some statistical information tracked to compute the mean, standard deviation, and quantile estimates.

    Min, max, and the p-* quantiles are treated as optional due to the possibility of distribution operations, like subtraction.
    """

    bins: list[float]
    counts: list[Count]
    max: Optional[float] = None
    min: Optional[float] = None
    p50: Optional[Quantile] = None
    p90: Optional[Quantile] = None
    p99: Optional[Quantile] = None
    squared_mean: float
    sum_of_samples: float


class Distributionint64(BaseModel):
    """
    A distribution is a sequence of bins and counts in those bins, and some statistical information tracked to compute the mean, standard deviation, and quantile estimates.

    Min, max, and the p-* quantiles are treated as optional due to the possibility of distribution operations, like subtraction.
    """

    bins: list[int]
    counts: list[Count]
    max: Optional[int] = None
    min: Optional[int] = None
    p50: Optional[Quantile] = None
    p90: Optional[Quantile] = None
    p99: Optional[Quantile] = None
    squared_mean: float
    sum_of_samples: int


class EphemeralIpCreate(BaseModel):
    """
    Parameters for creating an ephemeral IP address for an instance.
    """

    pool: Optional[NameOrId] = None
    """
    Name or ID of the IP pool used to allocate an address
    """


class ExternalIp2(BaseModel):
    """
    A Floating IP is a well-known IP address which can be attached and detached from instances.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    instance_id: Optional[UUID] = None
    """
    The ID of the instance that this Floating IP is attached to, if it is presently in use.
    """
    ip: str
    """
    The IP address held by this resource.
    """
    ip_pool_id: UUID
    """
    The ID of the IP pool this resource belongs to.
    """
    kind: Literal["floating"]
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    project_id: UUID
    """
    The project this resource exists within.
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class ExternalIp(RootModel[Union[ExternalIp1, ExternalIp2]]):
    root: Union[ExternalIp1, ExternalIp2]


class ExternalIpCreate1(BaseModel):
    """
    An IP address providing both inbound and outbound access. The address is automatically-assigned from the provided IP Pool, or the current silo's default pool if not specified.
    """

    pool: Optional[NameOrId] = None
    type: Literal["ephemeral"]


class ExternalIpCreate2(BaseModel):
    """
    An IP address providing both inbound and outbound access. The address is an existing floating IP object assigned to the current project.

    The floating IP must not be in use by another instance or service.
    """

    floating_ip: NameOrId
    type: Literal["floating"]


class ExternalIpCreate(RootModel[Union[ExternalIpCreate1, ExternalIpCreate2]]):
    root: Union[ExternalIpCreate1, ExternalIpCreate2]
    """
    Parameters for creating an external IP address for instances.
    """


class ExternalIpResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[ExternalIp]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class FieldSchema(BaseModel):
    """
    The name and type information for a field of a timeseries schema.
    """

    description: str
    field_type: FieldType
    name: str
    source: FieldSource


class FinalizeDisk(BaseModel):
    """
    Parameters for finalizing a disk
    """

    snapshot_name: Optional[Name] = None
    """
    If specified a snapshot of the disk will be created with the given name during finalization. If not specified, a snapshot for the disk will _not_ be created. A snapshot can be manually created once the disk transitions into the `Detached` state.
    """


class FleetRoleRoleAssignment(BaseModel):
    """
    Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)

    The resource is not part of this structure.  Rather, `RoleAssignment`s are put into a `Policy` and that Policy is applied to a particular resource.
    """

    identity_id: UUID
    identity_type: IdentityType
    role_name: FleetRole


class FloatingIp(BaseModel):
    """
    A Floating IP is a well-known IP address which can be attached and detached from instances.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    instance_id: Optional[UUID] = None
    """
    The ID of the instance that this Floating IP is attached to, if it is presently in use.
    """
    ip: str
    """
    The IP address held by this resource.
    """
    ip_pool_id: UUID
    """
    The ID of the IP pool this resource belongs to.
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    project_id: UUID
    """
    The project this resource exists within.
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class FloatingIpAttach(BaseModel):
    """
    Parameters for attaching a floating IP address to another resource
    """

    kind: FloatingIpParentKind
    """
    The type of `parent`'s resource
    """
    parent: NameOrId
    """
    Name or ID of the resource that this IP address should be attached to
    """


class FloatingIpCreate(BaseModel):
    """
    Parameters for creating a new floating IP address for instances.
    """

    description: str
    ip: Optional[str] = None
    """
    An IP address to reserve for use as a floating IP. This field is optional: when not set, an address will be automatically chosen from `pool`. If set, then the IP must be available in the resolved `pool`.
    """
    name: Name
    pool: Optional[NameOrId] = None
    """
    The parent IP pool that a floating IP is pulled from. If unset, the default pool is selected.
    """


class FloatingIpResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[FloatingIp]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class FloatingIpUpdate(BaseModel):
    """
    Updateable identity-related parameters
    """

    description: Optional[str] = None
    name: Optional[Name] = None


class Histogramdouble(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Bindouble]
    """
    The bins of the histogram.
    """
    max: float
    """
    The maximum value of all samples in the histogram.
    """
    min: float
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: float
    """
    The sum of all samples in the histogram.
    """


class Histogramfloat(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binfloat]
    """
    The bins of the histogram.
    """
    max: float
    """
    The maximum value of all samples in the histogram.
    """
    min: float
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: float
    """
    The sum of all samples in the histogram.
    """


class Histogramint16(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binint16]
    """
    The bins of the histogram.
    """
    max: int
    """
    The maximum value of all samples in the histogram.
    """
    min: int
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class Histogramint32(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binint32]
    """
    The bins of the histogram.
    """
    max: int
    """
    The maximum value of all samples in the histogram.
    """
    min: int
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class Histogramint64(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binint64]
    """
    The bins of the histogram.
    """
    max: int
    """
    The maximum value of all samples in the histogram.
    """
    min: int
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class Histogramint8(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binint8]
    """
    The bins of the histogram.
    """
    max: int
    """
    The maximum value of all samples in the histogram.
    """
    min: int
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class Histogramuint16(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binuint16]
    """
    The bins of the histogram.
    """
    max: Annotated[int, Field(ge=0)]
    """
    The maximum value of all samples in the histogram.
    """
    min: Annotated[int, Field(ge=0)]
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class Histogramuint32(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binuint32]
    """
    The bins of the histogram.
    """
    max: Annotated[int, Field(ge=0)]
    """
    The maximum value of all samples in the histogram.
    """
    min: Annotated[int, Field(ge=0)]
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class Histogramuint64(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binuint64]
    """
    The bins of the histogram.
    """
    max: Annotated[int, Field(ge=0)]
    """
    The maximum value of all samples in the histogram.
    """
    min: Annotated[int, Field(ge=0)]
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class Histogramuint8(BaseModel):
    """
    Histogram metric

    A histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any "gaps" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.

    Note that any gaps, unsorted bins, or non-finite values will result in an error.
    """

    bins: list[Binuint8]
    """
    The bins of the histogram.
    """
    max: Annotated[int, Field(ge=0)]
    """
    The maximum value of all samples in the histogram.
    """
    min: Annotated[int, Field(ge=0)]
    """
    The minimum value of all samples in the histogram.
    """
    n_samples: Annotated[int, Field(ge=0)]
    """
    The total number of samples in the histogram.
    """
    p50: Quantile
    """
    p50 Quantile
    """
    p90: Quantile
    """
    p95 Quantile
    """
    p99: Quantile
    """
    p99 Quantile
    """
    squared_mean: float
    """
    M2 for Welford's algorithm for variance calculation.

    Read about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.
    """
    start_time: datetime
    """
    The start time of the histogram.
    """
    sum_of_samples: int
    """
    The sum of all samples in the histogram.
    """


class IdentityProvider(BaseModel):
    """
    View of an Identity Provider
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    provider_type: IdentityProviderType
    """
    Identity provider type
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class IdentityProviderResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[IdentityProvider]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Image(BaseModel):
    """
    View of an image

    If `project_id` is present then the image is only visible inside that project. If it's not present then the image is visible to all projects in the silo.
    """

    block_size: ByteCount
    """
    size of blocks in bytes
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    digest: Optional[Digest] = None
    """
    Hash of the image contents, if applicable
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    os: str
    """
    The family of the operating system like Debian, Ubuntu, etc.
    """
    project_id: Optional[UUID] = None
    """
    ID of the parent project if the image is a project image
    """
    size: ByteCount
    """
    total size in bytes
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    version: str
    """
    Version of the operating system
    """


class ImageCreate(BaseModel):
    """
    Create-time parameters for an `Image`
    """

    description: str
    name: Name
    os: str
    """
    The family of the operating system (e.g. Debian, Ubuntu, etc.)
    """
    source: ImageSource
    """
    The source of the image's contents.
    """
    version: str
    """
    The version of the operating system (e.g. 18.04, 20.04, etc.)
    """


class ImageResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Image]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Instance(BaseModel):
    """
    View of an Instance
    """

    auto_restart_cooldown_expiration: Optional[datetime] = None
    """
    The time at which the auto-restart cooldown period for this instance completes, permitting it to be automatically restarted again. If the instance enters the `Failed` state, it will not be restarted until after this time.

    If this is not present, then either the instance has never been automatically restarted, or the cooldown period has already expired, allowing the instance to be restarted immediately if it fails.
    """
    auto_restart_enabled: bool
    """
    `true` if this instance's auto-restart policy will permit the control plane to automatically restart it if it enters the `Failed` state.
    """
    auto_restart_policy: Optional[InstanceAutoRestartPolicy] = None
    """
    The auto-restart policy configured for this instance, or `null` if no explicit policy has been configured.

    This policy determines whether the instance should be automatically restarted by the control plane on failure. If this is `null`, the control plane will use the default policy when determining whether or not to automatically restart this instance, which may or may not allow it to be restarted. The value of the `auto_restart_enabled` field indicates whether the instance will be auto-restarted, based on its current policy or the default if it has no configured policy.
    """
    boot_disk_id: Optional[UUID] = None
    """
    the ID of the disk used to boot this Instance, if a specific one is assigned.
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    hostname: str
    """
    RFC1035-compliant hostname for the Instance.
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    memory: ByteCount
    """
    memory allocated for this Instance
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    ncpus: InstanceCpuCount
    """
    number of CPUs allocated for this Instance
    """
    project_id: UUID
    """
    id for the project containing this Instance
    """
    run_state: InstanceState
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_last_auto_restarted: Optional[datetime] = None
    """
    The timestamp of the most recent time this instance was automatically restarted by the control plane.

    If this is not present, then this instance has not been automatically restarted.
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    time_run_state_updated: datetime


class InstanceDiskAttachment1(BaseModel):
    """
    During instance creation, create and attach disks
    """

    description: str
    disk_source: DiskSource
    """
    The initial source for this disk
    """
    name: Name
    size: ByteCount
    """
    The total size of the Disk (in bytes)
    """
    type: Literal["create"]


class InstanceDiskAttachment2(BaseModel):
    """
    During instance creation, attach this disk
    """

    name: Name
    """
    A disk name to attach
    """
    type: Literal["attach"]


class InstanceDiskAttachment(
    RootModel[Union[InstanceDiskAttachment1, InstanceDiskAttachment2]]
):
    root: Union[InstanceDiskAttachment1, InstanceDiskAttachment2]
    """
    Describe the instance's disks at creation time
    """


class InstanceNetworkInterfaceCreate(BaseModel):
    """
    Create-time parameters for an `InstanceNetworkInterface`
    """

    description: str
    ip: Optional[str] = None
    """
    The IP address for the interface. One will be auto-assigned if not provided.
    """
    name: Name
    subnet_name: Name
    """
    The VPC Subnet in which to create the interface.
    """
    vpc_name: Name
    """
    The VPC in which to create the interface.
    """


class InstanceResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Instance]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class InstanceUpdate(BaseModel):
    """
    Parameters of an `Instance` that can be reconfigured after creation.
    """

    auto_restart_policy: Optional[InstanceAutoRestartPolicy] = None
    """
    Sets the auto-restart policy for this instance.

    This policy determines whether the instance should be automatically restarted by the control plane on failure. If this is `null`, any explicitly configured auto-restart policy will be unset, and the control plane will select the default policy when determining whether the instance can be automatically restarted.

    Currently, the global default auto-restart policy is "best-effort", so instances with `null` auto-restart policies will be automatically restarted. However, in the future, the default policy may be configurable through other mechanisms, such as on a per-project basis. In that case, any configured default policy will be used if this is `null`.
    """
    boot_disk: Optional[NameOrId] = None
    """
    Name or ID of the disk the instance should be instructed to boot from.

    If not provided, unset the instance's boot disk.
    """
    memory: ByteCount
    """
    The amount of memory to assign to this instance.
    """
    ncpus: InstanceCpuCount
    """
    The number of CPUs to assign to this instance.
    """


class InternetGateway(BaseModel):
    """
    An internet gateway provides a path between VPC networks and external networks.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    vpc_id: UUID
    """
    The VPC to which the gateway belongs.
    """


class InternetGatewayCreate(BaseModel):
    """
    Create-time parameters for an `InternetGateway`
    """

    description: str
    name: Name


class InternetGatewayIpAddress(BaseModel):
    """
    An IP address that is attached to an internet gateway
    """

    address: str
    """
    The associated IP address,
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    internet_gateway_id: UUID
    """
    The associated internet gateway.
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class InternetGatewayIpAddressCreate(BaseModel):
    """
    Create-time identity-related parameters
    """

    address: str
    description: str
    name: Name


class InternetGatewayIpAddressResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[InternetGatewayIpAddress]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class InternetGatewayIpPool(BaseModel):
    """
    An IP pool that is attached to an internet gateway
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    internet_gateway_id: UUID
    """
    The associated internet gateway.
    """
    ip_pool_id: UUID
    """
    The associated IP pool.
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class InternetGatewayIpPoolCreate(BaseModel):
    """
    Create-time identity-related parameters
    """

    description: str
    ip_pool: NameOrId
    name: Name


class InternetGatewayIpPoolResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[InternetGatewayIpPool]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class InternetGatewayResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[InternetGateway]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class IpNet(RootModel[Union[Ipv4Net, Ipv6Net]]):
    root: Union[Ipv4Net, Ipv6Net]


class IpPool(BaseModel):
    """
    A collection of IP ranges. If a pool is linked to a silo, IP addresses from the pool can be allocated within that silo
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class IpPoolCreate(BaseModel):
    """
    Create-time parameters for an `IpPool`
    """

    description: str
    name: Name


class IpPoolLinkSilo(BaseModel):
    is_default: bool
    """
    When a pool is the default for a silo, floating IPs and instance ephemeral IPs will come from that pool when no other pool is specified. There can be at most one default for a given silo.
    """
    silo: NameOrId


class IpPoolResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[IpPool]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class IpPoolUpdate(BaseModel):
    """
    Parameters for updating an IP Pool
    """

    description: Optional[str] = None
    name: Optional[Name] = None


class IpPoolUtilization(BaseModel):
    ipv4: Ipv4Utilization
    """
    Number of allocated and total available IPv4 addresses in pool
    """
    ipv6: Ipv6Utilization
    """
    Number of allocated and total available IPv6 addresses in pool
    """


class IpRange(RootModel[Union[Ipv4Range, Ipv6Range]]):
    root: Union[Ipv4Range, Ipv6Range]


class LinkConfigCreate(BaseModel):
    """
    Switch link configuration.
    """

    autoneg: bool
    """
    Whether or not to set autonegotiation
    """
    fec: Optional[LinkFec] = None
    """
    The requested forward-error correction method.  If this is not specified, the standard FEC for the underlying media will be applied if it can be determined.
    """
    lldp: LldpLinkConfigCreate
    """
    The link-layer discovery protocol (LLDP) configuration for the link.
    """
    mtu: Annotated[int, Field(ge=0)]
    """
    Maximum transmission unit for the link.
    """
    speed: LinkSpeed
    """
    The speed of the link.
    """
    tx_eq: Optional[TxEqConfig] = None
    """
    Optional tx_eq settings
    """


class LldpLinkConfig(BaseModel):
    """
    A link layer discovery protocol (LLDP) service configuration.
    """

    chassis_id: Optional[str] = None
    """
    The LLDP chassis identifier TLV.
    """
    enabled: bool
    """
    Whether or not the LLDP service is enabled.
    """
    id: UUID
    """
    The id of this LLDP service instance.
    """
    link_description: Optional[str] = None
    """
    The LLDP link description TLV.
    """
    link_name: Optional[str] = None
    """
    The LLDP link name TLV.
    """
    management_ip: Optional[IpNet] = None
    """
    The LLDP management IP TLV.
    """
    system_description: Optional[str] = None
    """
    The LLDP system description TLV.
    """
    system_name: Optional[str] = None
    """
    The LLDP system name TLV.
    """


class LldpNeighbor(BaseModel):
    """
    Information about LLDP advertisements from other network entities directly connected to a switch port.  This structure contains both metadata about when and where the neighbor was seen, as well as the specific information the neighbor was advertising.
    """

    chassis_id: str
    """
    The LLDP chassis identifier advertised by the neighbor
    """
    first_seen: datetime
    """
    Initial sighting of this LldpNeighbor
    """
    last_seen: datetime
    """
    Most recent sighting of this LldpNeighbor
    """
    link_description: Optional[str] = None
    """
    The LLDP link description advertised by the neighbor
    """
    link_name: str
    """
    The LLDP link name advertised by the neighbor
    """
    local_port: str
    """
    The port on which the neighbor was seen
    """
    management_ip: list[IpNet]
    """
    The LLDP management IP(s) advertised by the neighbor
    """
    system_description: Optional[str] = None
    """
    The LLDP system description advertised by the neighbor
    """
    system_name: Optional[str] = None
    """
    The LLDP system name advertised by the neighbor
    """


class LldpNeighborResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[LldpNeighbor]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class LoopbackAddress(BaseModel):
    """
    A loopback address is an address that is assigned to a rack switch but is not associated with any particular port.
    """

    address: IpNet
    """
    The loopback IP address and prefix length.
    """
    address_lot_block_id: UUID
    """
    The address lot block this address came from.
    """
    id: UUID
    """
    The id of the loopback address.
    """
    rack_id: UUID
    """
    The id of the rack where this loopback address is assigned.
    """
    switch_location: str
    """
    Switch location where this loopback address is assigned.
    """


class LoopbackAddressCreate(BaseModel):
    """
    Parameters for creating a loopback address on a particular rack switch.
    """

    address: str
    """
    The address to create.
    """
    address_lot: NameOrId
    """
    The name or id of the address lot this loopback address will pull an address from.
    """
    anycast: bool
    """
    Address is an anycast address. This allows the address to be assigned to multiple locations simultaneously.
    """
    mask: Annotated[int, Field(ge=0)]
    """
    The subnet mask to use for the address.
    """
    rack_id: UUID
    """
    The containing the switch this loopback address will be configured on.
    """
    switch_location: Name
    """
    The location of the switch within the rack this loopback address will be configured on.
    """


class LoopbackAddressResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[LoopbackAddress]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class NetworkInterface(BaseModel):
    """
    Information required to construct a virtual network interface
    """

    id: UUID
    ip: str
    kind: NetworkInterfaceKind
    mac: MacAddr
    name: Name
    primary: bool
    slot: Annotated[int, Field(ge=0)]
    subnet: IpNet
    transit_ips: list[IpNet] = []
    vni: Vni


class PhysicalDisk(BaseModel):
    """
    View of a Physical Disk

    Physical disks reside in a particular sled and are used to store both Instance Disk data as well as internal metadata.
    """

    form_factor: PhysicalDiskKind
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    model: str
    policy: PhysicalDiskPolicy
    """
    The operator-defined policy for a physical disk.
    """
    serial: str
    sled_id: Optional[UUID] = None
    """
    The sled to which this disk is attached, if any.
    """
    state: PhysicalDiskState
    """
    The current state Nexus believes the disk to be in.
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    vendor: str


class PhysicalDiskResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[PhysicalDisk]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Ping(BaseModel):
    status: PingStatus
    """
    Whether the external API is reachable. Will always be Ok if the endpoint returns anything at all.
    """


class ProbeExternalIp(BaseModel):
    first_port: Annotated[int, Field(ge=0)]
    ip: str
    kind: ProbeExternalIpKind
    last_port: Annotated[int, Field(ge=0)]


class ProbeInfo(BaseModel):
    external_ips: list[ProbeExternalIp]
    id: UUID
    interface: NetworkInterface
    name: Name
    sled: UUID


class ProbeInfoResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[ProbeInfo]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class ProjectRolePolicy(BaseModel):
    """
    Policy for a particular resource

    Note that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource.
    """

    role_assignments: list[ProjectRoleRoleAssignment]
    """
    Roles directly assigned on this resource
    """


class Role(BaseModel):
    """
    View of a Role
    """

    description: str
    name: RoleName


class RoleResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Role]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Route(BaseModel):
    """
    A route to a destination network through a gateway address.
    """

    dst: IpNet
    """
    The route destination.
    """
    gw: str
    """
    The route gateway.
    """
    rib_priority: Annotated[Optional[int], Field(ge=0)] = None
    """
    Local preference for route. Higher preference indictes precedence within and across protocols.
    """
    vid: Annotated[Optional[int], Field(ge=0)] = None
    """
    VLAN id the gateway is reachable over.
    """


class RouteConfig(BaseModel):
    """
    Route configuration data associated with a switch port configuration.
    """

    routes: list[Route]
    """
    The set of routes assigned to a switch port.
    """


class RouteDestination2(BaseModel):
    """
    Route applies to traffic destined for the specified IP subnet
    """

    type: Literal["ip_net"]
    value: IpNet


class RouteDestination(
    RootModel[
        Union[
            RouteDestination1, RouteDestination2, RouteDestination3, RouteDestination4
        ]
    ]
):
    root: Union[
        RouteDestination1, RouteDestination2, RouteDestination3, RouteDestination4
    ]
    """
    A `RouteDestination` is used to match traffic with a routing rule based on the destination of that traffic.

    When traffic is to be sent to a destination that is within a given `RouteDestination`, the corresponding `RouterRoute` applies, and traffic will be forward to the `RouteTarget` for that rule.
    """


class RouterRoute(BaseModel):
    """
    A route defines a rule that governs where traffic should be sent based on its destination.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    destination: RouteDestination
    """
    Selects which traffic this routing rule will apply to
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    kind: RouterRouteKind
    """
    Describes the kind of router. Set at creation. `read-only`
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    target: RouteTarget
    """
    The location that matched packets should be forwarded to
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    vpc_router_id: UUID
    """
    The ID of the VPC Router to which the route belongs
    """


class RouterRouteCreate(BaseModel):
    """
    Create-time parameters for a `RouterRoute`
    """

    description: str
    destination: RouteDestination
    """
    Selects which traffic this routing rule will apply to.
    """
    name: Name
    target: RouteTarget
    """
    The location that matched packets should be forwarded to.
    """


class RouterRouteResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[RouterRoute]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class RouterRouteUpdate(BaseModel):
    """
    Updateable properties of a `RouterRoute`
    """

    description: Optional[str] = None
    destination: RouteDestination
    """
    Selects which traffic this routing rule will apply to.
    """
    name: Optional[Name] = None
    target: RouteTarget
    """
    The location that matched packets should be forwarded to.
    """


class Silo(BaseModel):
    """
    View of a Silo

    A Silo is the highest level unit of isolation.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    discoverable: bool
    """
    A silo where discoverable is false can be retrieved only by its id - it will not be part of the "list all silos" output.
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    identity_mode: SiloIdentityMode
    """
    How users and groups are managed in this Silo
    """
    mapped_fleet_roles: dict[str, list[FleetRole]]
    """
    Mapping of which Fleet roles are conferred by each Silo role

    The default is that no Fleet roles are conferred by any Silo roles unless there's a corresponding entry in this map.
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SiloCreate(BaseModel):
    """
    Create-time parameters for a `Silo`
    """

    admin_group_name: Optional[str] = None
    """
    If set, this group will be created during Silo creation and granted the "Silo Admin" role. Identity providers can assert that users belong to this group and those users can log in and further initialize the Silo.

    Note that if configuring a SAML based identity provider, group_attribute_name must be set for users to be considered part of a group. See `SamlIdentityProviderCreate` for more information.
    """
    description: str
    discoverable: bool
    identity_mode: SiloIdentityMode
    mapped_fleet_roles: dict[str, list[FleetRole]] = {}
    """
    Mapping of which Fleet roles are conferred by each Silo role

    The default is that no Fleet roles are conferred by any Silo roles unless there's a corresponding entry in this map.
    """
    name: Name
    quotas: SiloQuotasCreate
    """
    Limits the amount of provisionable CPU, memory, and storage in the Silo. CPU and memory are only consumed by running instances, while storage is consumed by any disk or snapshot. A value of 0 means that resource is *not* provisionable.
    """
    tls_certificates: list[CertificateCreate]
    """
    Initial TLS certificates to be used for the new Silo's console and API endpoints.  These should be valid for the Silo's DNS name(s).
    """


class SiloResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Silo]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SiloRolePolicy(BaseModel):
    """
    Policy for a particular resource

    Note that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource.
    """

    role_assignments: list[SiloRoleRoleAssignment]
    """
    Roles directly assigned on this resource
    """


class SiloUtilization(BaseModel):
    """
    View of a silo's resource utilization and capacity
    """

    allocated: VirtualResourceCounts
    """
    Accounts for the total amount of resources reserved for silos via their quotas
    """
    provisioned: VirtualResourceCounts
    """
    Accounts for resources allocated by in silos like CPU or memory for running instances and storage for disks and snapshots Note that CPU and memory resources associated with a stopped instances are not counted here
    """
    silo_id: UUID
    silo_name: Name


class SiloUtilizationResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SiloUtilization]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SledPolicy1(BaseModel):
    """
    The operator has indicated that the sled is in-service.
    """

    kind: Literal["in_service"]
    provision_policy: SledProvisionPolicy
    """
    Determines whether new resources can be provisioned onto the sled.
    """


class SledPolicy(RootModel[Union[SledPolicy1, SledPolicy2]]):
    root: Union[SledPolicy1, SledPolicy2]
    """
    The operator-defined policy of a sled.
    """


class Snapshot(BaseModel):
    """
    View of a Snapshot
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    disk_id: UUID
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    project_id: UUID
    size: ByteCount
    state: SnapshotState
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """


class SnapshotResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Snapshot]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SupportBundleInfo(BaseModel):
    id: TypedUuidForSupportBundleKind
    reason_for_creation: str
    reason_for_failure: Optional[str] = None
    state: SupportBundleState
    time_created: datetime


class SupportBundleInfoResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[SupportBundleInfo]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class SwitchBgpHistory(BaseModel):
    """
    BGP message history for a particular switch.
    """

    history: dict[str, BgpMessageHistory]
    """
    Message history indexed by peer address.
    """
    switch: SwitchLocation
    """
    Switch this message history is associated with.
    """


class SwitchInterfaceConfig(BaseModel):
    """
    A switch port interface configuration for a port settings object.
    """

    id: UUID
    """
    A unique identifier for this switch interface.
    """
    interface_name: str
    """
    The name of this switch interface.
    """
    kind: SwitchInterfaceKind2
    """
    The switch interface kind.
    """
    port_settings_id: UUID
    """
    The port settings object this switch interface configuration belongs to.
    """
    v6_enabled: bool
    """
    Whether or not IPv6 is enabled on this interface.
    """


class SwitchInterfaceConfigCreate(BaseModel):
    """
    A layer-3 switch interface configuration. When IPv6 is enabled, a link local address will be created for the interface.
    """

    kind: SwitchInterfaceKind
    """
    What kind of switch interface this configuration represents.
    """
    v6_enabled: bool
    """
    Whether or not IPv6 is enabled.
    """


class SwitchPortAddressConfig(BaseModel):
    """
    An IP address configuration for a port settings object.
    """

    address: IpNet
    """
    The IP address and prefix.
    """
    address_lot_block_id: UUID
    """
    The id of the address lot block this address is drawn from.
    """
    interface_name: str
    """
    The interface name this address belongs to.
    """
    port_settings_id: UUID
    """
    The port settings object this address configuration belongs to.
    """
    vlan_id: Annotated[Optional[int], Field(ge=0)] = None
    """
    An optional VLAN ID
    """


class SwitchPortConfig(BaseModel):
    """
    A physical port configuration for a port settings object.
    """

    geometry: SwitchPortGeometry2
    """
    The physical link geometry of the port.
    """
    port_settings_id: UUID
    """
    The id of the port settings object this configuration belongs to.
    """


class SwitchPortConfigCreate(BaseModel):
    """
    Physical switch port configuration.
    """

    geometry: SwitchPortGeometry
    """
    Link geometry for the switch port.
    """


class SwitchPortRouteConfig(BaseModel):
    """
    A route configuration for a port settings object.
    """

    dst: IpNet
    """
    The route's destination network.
    """
    gw: IpNet
    """
    The route's gateway address.
    """
    interface_name: str
    """
    The interface name this route configuration is assigned to.
    """
    port_settings_id: UUID
    """
    The port settings object this route configuration belongs to.
    """
    rib_priority: Annotated[Optional[int], Field(ge=0)] = None
    """
    RIB Priority indicating priority within and across protocols.
    """
    vlan_id: Annotated[Optional[int], Field(ge=0)] = None
    """
    The VLAN identifier for the route. Use this if the gateway is reachable over an 802.1Q tagged L2 segment.
    """


class TimeseriesSchema(BaseModel):
    """
    The schema for a timeseries.

    This includes the name of the timeseries, as well as the datum type of its metric and the schema for each field.
    """

    authz_scope: AuthzScope
    created: datetime
    datum_type: DatumType
    description: TimeseriesDescription
    field_schema: list[FieldSchema]
    timeseries_name: TimeseriesName
    units: Units
    version: Annotated[int, Field(ge=1)]


class TimeseriesSchemaResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[TimeseriesSchema]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class UserCreate(BaseModel):
    """
    Create-time parameters for a `User`
    """

    external_id: UserId
    """
    username used to log in
    """
    password: UserPassword
    """
    how to set the user's login password
    """


class Utilization(BaseModel):
    """
    View of the current silo's resource utilization and capacity
    """

    capacity: VirtualResourceCounts
    """
    The total amount of resources that can be provisioned in this silo Actions that would exceed this limit will fail
    """
    provisioned: VirtualResourceCounts
    """
    Accounts for resources allocated to running instances or storage allocated via disks or snapshots Note that CPU and memory resources associated with a stopped instances are not counted here whereas associated disks will still be counted
    """


class ValueArray5(BaseModel):
    """
    List of data values for one timeseries.

    Each element is an option, where `None` represents a missing sample.
    """

    type: Literal["integer_distribution"]
    values: list[Distributionint64]


class ValueArray6(BaseModel):
    """
    List of data values for one timeseries.

    Each element is an option, where `None` represents a missing sample.
    """

    type: Literal["double_distribution"]
    values: list[Distributiondouble]


class ValueArray(
    RootModel[
        Union[
            ValueArray1, ValueArray2, ValueArray3, ValueArray4, ValueArray5, ValueArray6
        ]
    ]
):
    root: Union[
        ValueArray1, ValueArray2, ValueArray3, ValueArray4, ValueArray5, ValueArray6
    ]
    """
    List of data values for one timeseries.

    Each element is an option, where `None` represents a missing sample.
    """


class Values(BaseModel):
    """
    A single list of values, for one dimension of a timeseries.
    """

    metric_type: MetricType
    """
    The type of this metric.
    """
    values: ValueArray
    """
    The data values.
    """


class VpcFirewallRuleHostFilter5(BaseModel):
    """
    The rule applies to traffic from/to a specific IP subnet
    """

    type: Literal["ip_net"]
    value: IpNet


class VpcFirewallRuleHostFilter(
    RootModel[
        Union[
            VpcFirewallRuleHostFilter1,
            VpcFirewallRuleHostFilter2,
            VpcFirewallRuleHostFilter3,
            VpcFirewallRuleHostFilter4,
            VpcFirewallRuleHostFilter5,
        ]
    ]
):
    root: Union[
        VpcFirewallRuleHostFilter1,
        VpcFirewallRuleHostFilter2,
        VpcFirewallRuleHostFilter3,
        VpcFirewallRuleHostFilter4,
        VpcFirewallRuleHostFilter5,
    ]
    """
    The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis of its source or destination host.
    """


class VpcFirewallRuleTarget5(BaseModel):
    """
    The rule applies to a specific IP subnet
    """

    type: Literal["ip_net"]
    value: IpNet


class VpcFirewallRuleTarget(
    RootModel[
        Union[
            VpcFirewallRuleTarget1,
            VpcFirewallRuleTarget2,
            VpcFirewallRuleTarget3,
            VpcFirewallRuleTarget4,
            VpcFirewallRuleTarget5,
        ]
    ]
):
    root: Union[
        VpcFirewallRuleTarget1,
        VpcFirewallRuleTarget2,
        VpcFirewallRuleTarget3,
        VpcFirewallRuleTarget4,
        VpcFirewallRuleTarget5,
    ]
    """
    A `VpcFirewallRuleTarget` is used to specify the set of instances to which a firewall rule applies. You can target instances directly by name, or specify a VPC, VPC subnet, IP, or IP subnet, which will apply the rule to traffic going to all matching instances. Targets are additive: the rule applies to instances matching ANY target.
    """


class VpcRouter(BaseModel):
    """
    A VPC router defines a series of rules that indicate where traffic should be sent depending on its destination.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    kind: VpcRouterKind
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    vpc_id: UUID
    """
    The VPC to which the router belongs.
    """


class VpcRouterResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[VpcRouter]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Address(BaseModel):
    """
    An address tied to an address lot.
    """

    address: IpNet
    """
    The address and prefix length of this address.
    """
    address_lot: NameOrId
    """
    The address lot this address is drawn from.
    """
    vlan_id: Annotated[Optional[int], Field(ge=0)] = None
    """
    Optional VLAN ID for this address
    """


class AddressConfig(BaseModel):
    """
    A set of addresses associated with a port configuration.
    """

    addresses: list[Address]
    """
    The set of addresses assigned to the port configuration.
    """


class AggregateBgpMessageHistory(BaseModel):
    """
    BGP message history for rack switches.
    """

    switch_histories: list[SwitchBgpHistory]
    """
    BGP history organized by switch.
    """


class AllowedSourceIps2(BaseModel):
    """
    Restrict access to a specific set of source IP addresses or subnets.

    All others are prevented from reaching rack services.
    """

    allow: Literal["list"]
    ips: list[IpNet]


class AllowedSourceIps(RootModel[Union[AllowedSourceIps1, AllowedSourceIps2]]):
    root: Union[AllowedSourceIps1, AllowedSourceIps2]
    """
    Description of source IPs allowed to reach rack services.
    """


class BgpAnnouncement(BaseModel):
    """
    A BGP announcement tied to an address lot block.
    """

    address_lot_block_id: UUID
    """
    The address block the IP network being announced is drawn from.
    """
    announce_set_id: UUID
    """
    The id of the set this announcement is a part of.
    """
    network: IpNet
    """
    The IP network being announced.
    """


class BgpAnnouncementCreate(BaseModel):
    """
    A BGP announcement tied to a particular address lot block.
    """

    address_lot_block: NameOrId
    """
    Address lot this announcement is drawn from.
    """
    network: IpNet
    """
    The network being announced.
    """


class Datum18(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramint8
    type: Literal["histogram_i8"]


class Datum19(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramuint8
    type: Literal["histogram_u8"]


class Datum20(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramint16
    type: Literal["histogram_i16"]


class Datum21(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramuint16
    type: Literal["histogram_u16"]


class Datum22(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramint32
    type: Literal["histogram_i32"]


class Datum23(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramuint32
    type: Literal["histogram_u32"]


class Datum24(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramint64
    type: Literal["histogram_i64"]


class Datum25(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramuint64
    type: Literal["histogram_u64"]


class Datum26(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramfloat
    type: Literal["histogram_f32"]


class Datum27(BaseModel):
    """
    A `Datum` is a single sampled data point from a metric.
    """

    datum: Histogramdouble
    type: Literal["histogram_f64"]


class Datum(
    RootModel[
        Union[
            Datum1,
            Datum2,
            Datum3,
            Datum4,
            Datum5,
            Datum6,
            Datum7,
            Datum8,
            Datum9,
            Datum10,
            Datum11,
            Datum12,
            Datum13,
            Datum14,
            Datum15,
            Datum16,
            Datum17,
            Datum18,
            Datum19,
            Datum20,
            Datum21,
            Datum22,
            Datum23,
            Datum24,
            Datum25,
            Datum26,
            Datum27,
            Datum28,
        ]
    ]
):
    root: Union[
        Datum1,
        Datum2,
        Datum3,
        Datum4,
        Datum5,
        Datum6,
        Datum7,
        Datum8,
        Datum9,
        Datum10,
        Datum11,
        Datum12,
        Datum13,
        Datum14,
        Datum15,
        Datum16,
        Datum17,
        Datum18,
        Datum19,
        Datum20,
        Datum21,
        Datum22,
        Datum23,
        Datum24,
        Datum25,
        Datum26,
        Datum27,
        Datum28,
    ]
    """
    A `Datum` is a single sampled data point from a metric.
    """


class FleetRolePolicy(BaseModel):
    """
    Policy for a particular resource

    Note that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource.
    """

    role_assignments: list[FleetRoleRoleAssignment]
    """
    Roles directly assigned on this resource
    """


class ImportExportPolicy2(BaseModel):
    """
    Define policy relating to the import and export of prefixes from a BGP peer.
    """

    type: Literal["allow"]
    value: list[IpNet]


class ImportExportPolicy(RootModel[Union[ImportExportPolicy1, ImportExportPolicy2]]):
    root: Union[ImportExportPolicy1, ImportExportPolicy2]
    """
    Define policy relating to the import and export of prefixes from a BGP peer.
    """


class InstanceNetworkInterface(BaseModel):
    """
    An `InstanceNetworkInterface` represents a virtual network interface device attached to an instance.
    """

    description: str
    """
    human-readable free-form text about a resource
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    instance_id: UUID
    """
    The Instance to which the interface belongs.
    """
    ip: str
    """
    The IP address assigned to this interface.
    """
    mac: MacAddr
    """
    The MAC address assigned to this interface.
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    primary: bool
    """
    True if this interface is the primary for the instance to which it's attached.
    """
    subnet_id: UUID
    """
    The subnet to which the interface belongs.
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    transit_ips: list[IpNet] = []
    """
    A set of additional networks that this interface may send and receive traffic on.
    """
    vpc_id: UUID
    """
    The VPC to which the interface belongs.
    """


class InstanceNetworkInterfaceAttachment1(BaseModel):
    """
    Create one or more `InstanceNetworkInterface`s for the `Instance`.

    If more than one interface is provided, then the first will be designated the primary interface for the instance.
    """

    params: list[InstanceNetworkInterfaceCreate]
    type: Literal["create"]


class InstanceNetworkInterfaceAttachment(
    RootModel[
        Union[
            InstanceNetworkInterfaceAttachment1,
            InstanceNetworkInterfaceAttachment2,
            InstanceNetworkInterfaceAttachment3,
        ]
    ]
):
    root: Union[
        InstanceNetworkInterfaceAttachment1,
        InstanceNetworkInterfaceAttachment2,
        InstanceNetworkInterfaceAttachment3,
    ]
    """
    Describes an attachment of an `InstanceNetworkInterface` to an `Instance`, at the time the instance is created.
    """


class InstanceNetworkInterfaceResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[InstanceNetworkInterface]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class InstanceNetworkInterfaceUpdate(BaseModel):
    """
    Parameters for updating an `InstanceNetworkInterface`

    Note that modifying IP addresses for an interface is not yet supported, a new interface must be created instead.
    """

    description: Optional[str] = None
    name: Optional[Name] = None
    primary: bool = False
    """
    Make a secondary interface the instance's primary interface.

    If applied to a secondary interface, that interface will become the primary on the next reboot of the instance. Note that this may have implications for routing between instances, as the new primary interface will be on a distinct subnet from the previous primary interface.

    Note that this can only be used to select a new primary interface for an instance. Requests to change the primary interface into a secondary will return an error.
    """
    transit_ips: list[IpNet] = []
    """
    A set of additional networks that this interface may send and receive traffic on.
    """


class IpPoolRange(BaseModel):
    id: UUID
    ip_pool_id: UUID
    range: IpRange
    time_created: datetime


class IpPoolRangeResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[IpPoolRange]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Measurement(BaseModel):
    """
    A `Measurement` is a timestamped datum from a single metric
    """

    datum: Datum
    timestamp: datetime


class MeasurementResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Measurement]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Points(BaseModel):
    """
    Timepoints and values for one timeseries.
    """

    start_times: Optional[list[datetime]] = None
    timestamps: list[datetime]
    values: list[Values]


class Sled(BaseModel):
    """
    An operator's view of a Sled.
    """

    baseboard: Baseboard
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    policy: SledPolicy
    """
    The operator-defined policy of a sled.
    """
    rack_id: UUID
    """
    The rack to which this Sled is currently attached
    """
    state: SledState
    """
    The current state Nexus believes the sled to be in.
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    usable_hardware_threads: Annotated[int, Field(ge=0)]
    """
    The number of hardware threads which can execute on this sled
    """
    usable_physical_ram: ByteCount
    """
    Amount of RAM which may be used by the Sled's OS
    """


class SledResultsPage(BaseModel):
    """
    A single page of results
    """

    items: list[Sled]
    """
    list of items on this page of results
    """
    next_page: Optional[str] = None
    """
    token used to fetch the next page of results (if any)
    """


class Timeseries(BaseModel):
    """
    A timeseries contains a timestamped set of values from one source.

    This includes the typed key-value pairs that uniquely identify it, and the set of timestamps and data values from it.
    """

    fields: dict[str, FieldValue]
    points: Points


class VpcFirewallRuleFilter(BaseModel):
    """
    Filters reduce the scope of a firewall rule. Without filters, the rule applies to all packets to the targets (or from the targets, if it's an outbound rule). With multiple filters, the rule applies only to packets matching ALL filters. The maximum number of each type of filter is 256.
    """

    hosts: Annotated[
        Optional[list[VpcFirewallRuleHostFilter]], Field(max_length=256)
    ] = None
    """
    If present, host filters match the "other end" of traffic from the targetâs perspective: for an inbound rule, they match the source of traffic. For an outbound rule, they match the destination.
    """
    ports: Annotated[Optional[list[L4PortRange]], Field(max_length=256)] = None
    """
    If present, the destination ports or port ranges this rule applies to.
    """
    protocols: Annotated[
        Optional[list[VpcFirewallRuleProtocol]], Field(max_length=256)
    ] = None
    """
    If present, the networking protocols this rule applies to.
    """


class VpcFirewallRuleUpdate(BaseModel):
    """
    A single rule in a VPC firewall
    """

    action: VpcFirewallRuleAction
    """
    Whether traffic matching the rule should be allowed or dropped
    """
    description: str
    """
    Human-readable free-form text about a resource
    """
    direction: VpcFirewallRuleDirection
    """
    Whether this rule is for incoming or outgoing traffic
    """
    filters: VpcFirewallRuleFilter
    """
    Reductions on the scope of the rule
    """
    name: Name
    """
    Name of the rule, unique to this VPC
    """
    priority: Annotated[int, Field(ge=0)]
    """
    The relative priority of this rule
    """
    status: VpcFirewallRuleStatus
    """
    Whether this rule is in effect
    """
    targets: Annotated[list[VpcFirewallRuleTarget], Field(max_length=256)]
    """
    Determine the set of instances that the rule applies to
    """


class VpcFirewallRuleUpdateParams(BaseModel):
    """
    Updated list of firewall rules. Will replace all existing rules.
    """

    rules: Annotated[list[VpcFirewallRuleUpdate], Field(max_length=1024)]


class AllowList(BaseModel):
    """
    Allowlist of IPs or subnets that can make requests to user-facing services.
    """

    allowed_ips: AllowedSourceIps
    """
    The allowlist of IPs or subnets.
    """
    time_created: datetime
    """
    Time the list was created.
    """
    time_modified: datetime
    """
    Time the list was last modified.
    """


class AllowListUpdate(BaseModel):
    """
    Parameters for updating allowed source IPs
    """

    allowed_ips: AllowedSourceIps
    """
    The new list of allowed source IPs.
    """


class BgpAnnounceSetCreate(BaseModel):
    """
    Parameters for creating a named set of BGP announcements.
    """

    announcement: list[BgpAnnouncementCreate]
    """
    The announcements in this set.
    """
    description: str
    name: Name


class BgpPeer(BaseModel):
    """
    A BGP peer configuration for an interface. Includes the set of announcements that will be advertised to the peer identified by `addr`. The `bgp_config` parameter is a reference to global BGP parameters. The `interface_name` indicates what interface the peer should be contacted on.
    """

    addr: str
    """
    The address of the host to peer with.
    """
    allowed_export: ImportExportPolicy
    """
    Define export policy for a peer.
    """
    allowed_import: ImportExportPolicy
    """
    Define import policy for a peer.
    """
    bgp_config: NameOrId
    """
    The global BGP configuration used for establishing a session with this peer.
    """
    communities: list[Community]
    """
    Include the provided communities in updates sent to the peer.
    """
    connect_retry: Annotated[int, Field(ge=0)]
    """
    How long to to wait between TCP connection retries (seconds).
    """
    delay_open: Annotated[int, Field(ge=0)]
    """
    How long to delay sending an open request after establishing a TCP session (seconds).
    """
    enforce_first_as: bool
    """
    Enforce that the first AS in paths received from this peer is the peer's AS.
    """
    hold_time: Annotated[int, Field(ge=0)]
    """
    How long to hold peer connections between keepalives (seconds).
    """
    idle_hold_time: Annotated[int, Field(ge=0)]
    """
    How long to hold a peer in idle before attempting a new session (seconds).
    """
    interface_name: str
    """
    The name of interface to peer on. This is relative to the port configuration this BGP peer configuration is a part of. For example this value could be phy0 to refer to a primary physical interface. Or it could be vlan47 to refer to a VLAN interface.
    """
    keepalive: Annotated[int, Field(ge=0)]
    """
    How often to send keepalive requests (seconds).
    """
    local_pref: Annotated[Optional[int], Field(ge=0)] = None
    """
    Apply a local preference to routes received from this peer.
    """
    md5_auth_key: Optional[str] = None
    """
    Use the given key for TCP-MD5 authentication with the peer.
    """
    min_ttl: Annotated[Optional[int], Field(ge=0)] = None
    """
    Require messages from a peer have a minimum IP time to live field.
    """
    multi_exit_discriminator: Annotated[Optional[int], Field(ge=0)] = None
    """
    Apply the provided multi-exit discriminator (MED) updates sent to the peer.
    """
    remote_asn: Annotated[Optional[int], Field(ge=0)] = None
    """
    Require that a peer has a specified ASN.
    """
    vlan_id: Annotated[Optional[int], Field(ge=0)] = None
    """
    Associate a VLAN ID with a peer.
    """


class BgpPeerConfig(BaseModel):
    peers: list[BgpPeer]


class InstanceCreate(BaseModel):
    """
    Create-time parameters for an `Instance`
    """

    auto_restart_policy: Optional[InstanceAutoRestartPolicy] = None
    """
    The auto-restart policy for this instance.

    This policy determines whether the instance should be automatically restarted by the control plane on failure. If this is `null`, no auto-restart policy will be explicitly configured for this instance, and the control plane will select the default policy when determining whether the instance can be automatically restarted.

    Currently, the global default auto-restart policy is "best-effort", so instances with `null` auto-restart policies will be automatically restarted. However, in the future, the default policy may be configurable through other mechanisms, such as on a per-project basis. In that case, any configured default policy will be used if this is `null`.
    """
    boot_disk: Optional[InstanceDiskAttachment] = None
    """
    The disk this instance should boot into. This disk can either be attached if it already exists, or created, if it should be a new disk.

    It is strongly recommended to either provide a boot disk at instance creation, or update the instance after creation to set a boot disk.

    An instance without an explicit boot disk can be booted: the options are as managed by UEFI, and as controlled by the guest OS, but with some risk.  If this instance later has a disk attached or detached, it is possible that boot options can end up reordered, with the intended boot disk moved after the EFI shell in boot priority. This may result in an instance that only boots to the EFI shell until the desired disk is set as an explicit boot disk and the instance rebooted.
    """
    description: str
    disks: list[InstanceDiskAttachment] = []
    """
    The disks to be created or attached for this instance.
    """
    external_ips: list[ExternalIpCreate] = []
    """
    The external IP addresses provided to this instance.

    By default, all instances have outbound connectivity, but no inbound connectivity. These external addresses can be used to provide a fixed, known IP address for making inbound connections to the instance.
    """
    hostname: Hostname
    """
    The hostname to be assigned to the instance
    """
    memory: ByteCount
    """
    The amount of RAM (in bytes) to be allocated to the instance
    """
    name: Name
    ncpus: InstanceCpuCount
    """
    The number of vCPUs to be allocated to the instance
    """
    network_interfaces: Annotated[InstanceNetworkInterfaceAttachment, Field()] = {
        "type": "default"
    }
    """
    The network interfaces to be created for this instance.
    """
    ssh_public_keys: Optional[list[NameOrId]] = None
    """
    An allowlist of SSH public keys to be transferred to the instance via cloud-init during instance creation.

    If not provided, all SSH public keys from the user's profile will be sent. If an empty list is provided, no public keys will be transmitted to the instance.
    """
    start: bool = True
    """
    Should this instance be started upon creation; true by default.
    """
    user_data: str = ""
    """
    User data for instance initialization systems (such as cloud-init). Must be a Base64-encoded string, as specified in RFC 4648 Â§ 4 (+ and / characters with padding). Maximum 32 KiB unencoded data.
    """


class SwitchPortSettingsCreate(BaseModel):
    """
    Parameters for creating switch port settings. Switch port settings are the central data structure for setting up external networking. Switch port settings include link, interface, route, address and dynamic network protocol configuration.
    """

    addresses: dict[str, AddressConfig]
    """
    Addresses indexed by interface name.
    """
    bgp_peers: dict[str, BgpPeerConfig]
    """
    BGP peers indexed by interface name.
    """
    description: str
    groups: list[NameOrId]
    interfaces: dict[str, SwitchInterfaceConfigCreate]
    """
    Interfaces indexed by link name.
    """
    links: dict[str, LinkConfigCreate]
    """
    Links indexed by phy name. On ports that are not broken out, this is always phy0. On a 2x breakout the options are phy0 and phy1, on 4x phy0-phy3, etc.
    """
    name: Name
    port_config: SwitchPortConfigCreate
    routes: dict[str, RouteConfig]
    """
    Routes indexed by interface name.
    """


class SwitchPortSettingsView(BaseModel):
    """
    This structure contains all port settings information in one place. It's a convenience data structure for getting a complete view of a particular port's settings.
    """

    addresses: list[SwitchPortAddressConfig]
    """
    Layer 3 IP address settings.
    """
    bgp_peers: list[BgpPeer]
    """
    BGP peer settings.
    """
    groups: list[SwitchPortSettingsGroups]
    """
    Switch port settings included from other switch port settings groups.
    """
    interfaces: list[SwitchInterfaceConfig]
    """
    Layer 3 interface settings.
    """
    link_lldp: list[LldpLinkConfig]
    """
    Link-layer discovery protocol (LLDP) settings.
    """
    links: list[SwitchPortLinkConfig]
    """
    Layer 2 link settings.
    """
    port: SwitchPortConfig
    """
    Layer 1 physical port settings.
    """
    routes: list[SwitchPortRouteConfig]
    """
    IP route settings.
    """
    settings: SwitchPortSettings
    """
    The primary switch port settings handle.
    """
    tx_eq: list[TxEqConfig]
    """
    TX equalization settings.  These are optional, and most links will not need them.
    """
    vlan_interfaces: list[SwitchVlanInterfaceConfig]
    """
    Vlan interface settings.
    """


class Table(BaseModel):
    """
    A table represents one or more timeseries with the same schema.

    A table is the result of an OxQL query. It contains a name, usually the name of the timeseries schema from which the data is derived, and any number of timeseries, which contain the actual data.
    """

    name: str
    timeseries: dict[str, Timeseries]


class VpcFirewallRule(BaseModel):
    """
    A single rule in a VPC firewall
    """

    action: VpcFirewallRuleAction
    """
    Whether traffic matching the rule should be allowed or dropped
    """
    description: str
    """
    human-readable free-form text about a resource
    """
    direction: VpcFirewallRuleDirection
    """
    Whether this rule is for incoming or outgoing traffic
    """
    filters: VpcFirewallRuleFilter
    """
    Reductions on the scope of the rule
    """
    id: UUID
    """
    unique, immutable, system-controlled identifier for each resource
    """
    name: Name
    """
    unique, mutable, user-controlled identifier for each resource
    """
    priority: Annotated[int, Field(ge=0)]
    """
    The relative priority of this rule
    """
    status: VpcFirewallRuleStatus
    """
    Whether this rule is in effect
    """
    targets: list[VpcFirewallRuleTarget]
    """
    Determine the set of instances that the rule applies to
    """
    time_created: datetime
    """
    timestamp when this resource was created
    """
    time_modified: datetime
    """
    timestamp when this resource was last modified
    """
    vpc_id: UUID
    """
    The VPC to which this rule belongs
    """


class VpcFirewallRules(BaseModel):
    """
    Collection of a Vpc's firewall rules
    """

    rules: list[VpcFirewallRule]


class OxqlQueryResult(BaseModel):
    """
    The result of a successful OxQL query.
    """

    tables: list[Table]
    """
    Tables resulting from the query, each containing timeseries.
    """
